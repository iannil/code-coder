# GOALS

## 核心原则

基于 ZeroBot（极致轻量、高定制化的后台运行与通讯中枢）和 CodeCoder（深度理解代码、多模式的交互式开发终端）的核心能力，我们可以设计一个“企业级全域 AI 协同工作空间”。

简单的工作，使用智能体快速响应，复杂的工作使用多智能体协同拆解、分析、评估、规划后实现。自主研究和进化，主动使用线上资源和通过编程保底，确保解决问题。

它的核心设计理念是：让专业的人用专业的界面，让底层的 AI 在后台互通。 CodeCoder 作为“重型装甲”赋能研发，ZeroBot 作为“中央神经”连接万物，覆盖全公司所有角色的日常办公。

为了确保这份文档对 LLM（大语言模型）高度友好，我采用了高度结构化的 Markdown 语法、一致的专业术语、明确的层级关系以及模块化的功能矩阵。你可以直接将这份文档喂给其他大模型（如用于生成代码架构、生成测试用例或撰写商业计划书），大模型能够精准解析其上下文和逻辑约束。

## 1. 产品愿景与核心原则 (Product Vision & Core Principles)

1.1 产品定位
“智擎工作舱”是一个企业级全域 AI 协同工作空间。它通过解耦“路由调度”与“深度执行”，将全公司的研发、产品、运营、管理乃至金融投研体系无缝串联。

1.2 核心设计原则

* 交互零迁移 (Zero Habit Change)：专业的人用专业的界面。开发者留驻 IDE，非开发者使用企业 IM (飞书/钉钉/Slack/微信) 或 Web 端。
* 底层全互通 (Seamless Integration)：AI 在后台共享上下文，打破部门数据孤岛。
* 资产绝对安全 (Absolute Security)：核心代码本地化处理，机密数据网关层脱敏，零外部云端供应商锁定。
* 按需极低成本 (Cost-Efficiency)：摒弃全家桶 SaaS 订阅，采用轻量级算力部署 + API Token 统一按量计费。

---

## 2. 系统架构设计 (System Architecture Design)

系统采用“双脑协同 + 全局记忆”的三层架构：

### 2.1 表现层 (Interface Layer / Touchpoints)

按角色分发前端触点，不改变现有工作流：

* IDE 插件端：集成于 VS Code / JetBrains，供开发/量化工程师使用。
* IM 机器人端：集成于飞书/企业微信/Slack/Telegram，供 PM/运营/高管/交易员使用。
* Web 门户/管理台：轻量级网页，用于系统配置、权限划分和数据大盘展示。

### 2.2 引擎层 (Engine Layer / The "Double-Brain")

* 中枢神经 - ZeroBot (网关与调度器)：
  * 极低资源占用（内存 < 5MB），支持跨平台部署。
  * 统一接管公司所有 LLM 请求，提供模型路由、负载均衡。
  * 负责自动化任务流（Cron 定时任务、Webhook 监听）。
* 重型装甲 - CodeCoder (深度解析引擎)：
  * 基于 LSP（语言服务器协议）深度理解本地化代码库语法树和依赖关系。
  * 提供多模式终端交互，支持专业化智能体（Agents）挂载。

### 2.3 数据与记忆层 (Data & Memory Layer)

* 全局上下文枢纽 (Global Context Hub)：轻量级向量数据库（如 Milvus），存储跨部门的 PRD、会议纪要、风控告警日志，实现跨角色记忆共享。
* 本地私有代码库：通过 CodeCoder 在内网/本地安全解析。
* 动态沙箱策略库：存储敏感词正则、脱敏规则、风控阈值。

---

## 3. 核心组件功能定义 (Core Components Specification)

### 3.1 CodeCoder 核心模式与 Agent

| 模块/Agent | 定义与权限 | 典型应用场景 |
| :--- | :--- | :--- |
| `plan` 模式 | 只读探测。遍历代码树但不修改任何文件。 | 了解系统架构、评估需求可行性、生成依赖图。 |
| `build` 模式 | 读写执行。直接生成、插入或重构代码。 | 日常编码、自动化单测生成、精准重构。 |
| `@general` | 综合代码库问答代理。 | 跨文件逻辑追溯、BUG 排查。 |
| `@macro` | 宏观经济与周期研判代理。内置经济因果链逻辑。 | 宏观数据解读、多周期定位（康波/朱格拉等）。 |
| `@decision` | 投资决策评估代理。内置 CLOSE 五维评估框架。 | 评估资产配置组合、交易计划合理性诊断。 |
| `@trader` | 市场情绪与微观技术代理。 | 短线情绪周期定位、龙头股打板特征识别。 |

### 3.2 ZeroBot 核心能力

* 多模型路由 (Multi-Provider Routing)：内置对接 22+ LLM 供应商，可根据任务复杂度自动分配高智商模型（如 GPT-4o）或低成本模型（如 Claude-3-Haiku）。
* 安全沙箱 (Security Sandbox)：拦截包含机密信息（IP、秘钥、身份证号等）的 Prompt，执行阻断或脱敏替换。
* 异步调度 (Async Scheduler)：0.38秒极速唤醒，支持监听代码提交、邮件接收、定时时间戳。

### 3.3 自主求解与“编程保底”机制 (Autonomous Resolution & Fallback Engine)

本系统不仅是被动响应指令的工具，更是一个具备“目标导向 (Goal-Oriented)”和“自我纠错 (Self-Healing)”能力的闭环执行体。当面对超出当前知识库、缺乏现成工具或遭遇异常报错的复杂问题时，系统将自动降级触发“自主研究与兜底机制”。

#### 3.3.1 机制运行逻辑 (The 4-Step Evolution Loop)

* 步骤一：主动资源检索 (Proactive Online Research)
  * 触发条件：当模型置信度低于阈值，或遇到未知报错（如 API 变更、未记录的宏观经济概念）。
  * 执行动作：ZeroBot 自动挂载 `Web_Browser` 插件，跳出本地环境，主动检索线上资源（如查阅最新官方文档、抓取 GitHub Issues/StackOverflow 讨论、读取金融资讯）。
  * 目标：不依赖人类补充信息，AI 自己去互联网“查阅说明书”。
* 步骤二：动态“编程保底”兜底验证 (Programming as Fallback)
  * 触发条件：当常规 API 调用失败，或缺乏针对特定任务（如清洗某种罕见格式数据、抓取动态网页）的现成工具时。
  * 执行动作：CodeCoder 不会回答“我做不到”，而是现场编写一段一次性的 Python/Shell/Node.js 脚本（即所谓的“动态造轮子”）。
  * 沙箱执行：ZeroBot 在其隔离的 Docker 安全沙箱中运行这段由 AI 刚写好的代码，以极低成本进行真实测试。
* 步骤三：自主反思与无限重试 (Self-Reflection & Retry)
  * 执行动作：如果沙箱中的“保底脚本”运行报错（例如依赖缺失、语法错误），CodeCoder 会自动读取控制台的 stderr（错误日志），像真正的人类程序员一样进行反思（Reasoning），修改代码后再次提交 ZeroBot 执行。
  * 目标：持续迭代，直至终端输出 `Exit Code 0`（成功执行），死磕到底，确保解决问题。
* 步骤四：沉淀与进化 (Knowledge Extraction & Evolution)
  * 执行动作：一旦问题解决，ZeroBot 会将“引发报错的原因”+“最终成功的保底脚本/逻辑”提取为结构化经验，写入系统的全局上下文枢纽 (Global Context Hub / 向量数据库)。
  * 进化体现：下次无论是该员工还是其他同事遇到类似问题，系统不再需要重新搜索或反复报错，而是直接从“记忆”中提取已验证的成功方案。系统越用越聪明。

---

#### 3.3.2 场景体现 (Use Case Mapping)

为了让开发和测试团队明确如何落地上述机制，定义以下典型验收场景：

#### 场景 A：开发侧的未知报错处理 (Dev - Fallback)

1. 用户意图：开发者要求“接入最新的 Stripe v4 支付接口”。
2. 遇到阻碍：本地代码库太老，且模型训练数据停留在 v3 版本，常规生成失败。
3. 自主研究：ZeroBot 自动联网抓取 Stripe 官方最新的 v4 API 文档并传递给 CodeCoder。
4. 编程保底：CodeCoder 发现缺乏现成的 SDK，于是自主用 Python 写了一个临时的 HTTP 请求脚本在后台沙箱测试鉴权。
5. 反思进化：第一次测试报 `401 Unauthorized`，CodeCoder 分析日志发现需要附加新的 Header。自我修正代码后再次测试成功，最终将正确的逻辑转化为正式项目的 TypeScript 代码写入 IDE。

#### 场景 B：投研侧的数据清洗困境 (FinTech - Fallback)

1. 用户意图：分析师要求“提取证监会刚发布的一份 500 页 PDF 里的环保违规企业名单”。
2. 遇到阻碍：PDF 扫描件格式混乱，现有的常规 PDF 解析工具全部乱码。
3. 自主研究：ZeroBot 搜索发现针对这种表格，可以使用特定的 OCR 库（如 PaddleOCR）。
4. 编程保底：CodeCoder 现场编写一段 Python OCR 脚本，安装依赖并在后台执行。
5. 解决与记忆：脚本成功提取出名单交还给分析师。同时，这段处理复杂 PDF 的脚本被 ZeroBot 打上标签存入工具库。未来遇到类似 PDF 提取任务，系统自主进化出了新的原生能力。

## 4. 全角色功能需求矩阵 (Feature Matrix by Role)

### 4.1 研发侧 (R&D & Tech)

* F-DEV-01 [精准重构]：基于 LSP，输入指令即可全局跨文件重构，自动解决未定义变量问题。（依赖：CodeCoder `build`）
* F-DEV-02 [无损探测]：新入职员工或接手老项目时，生成代码时序图，零代码破坏风险。（依赖：CodeCoder `plan`）
* F-DEV-03 [异步 CR]：Git Push 触发 Webhook，自动运行静态扫描并在仓库或 IM 中评论低级漏洞。（依赖：ZeroBot）

### 4.2 产品与运营侧 (Product & Ops)

* F-PM-01 [敏捷 PRD 生成]：飞书发送杂乱会议纪要，IM 机器人自动转为结构化 PRD 及甘特图数据。（依赖：ZeroBot）
* F-PM-02 [盲盒式技术探测]：无需懂代码，在 Web 端询问新需求可行性，系统扫描代码库并返回人类可读的工时与风险预估。（依赖：ZeroBot 呼叫 CodeCoder `@general`）
* F-OPS-01 [工单智能分发]：提取多渠道用户反馈报错日志，自动生成 Jira Ticket 并分发至对应研发群组。（依赖：ZeroBot）

### 4.3 投研与量化金融侧 (FinTech / Macro / Trading)

* F-FIN-01 [经济数据因果链]：输入宏观指标（如 PMI/PPI），自动生成至下游产业（利润/就业）的传导影响图谱。（依赖：CodeCoder `@macro`）
* F-FIN-02 [CLOSE 决策评估]：提交投资计划，从成本、收敛度、开放性、可持续性、证据五维度输出风险诊断。（依赖：CodeCoder `@decision`）
* F-FIN-03 [情绪周期识别]：分析涨停/连板数据，判定当前处于“冰点/回暖/高潮/退潮”等短线周期。（依赖：CodeCoder `@trader`）
* F-FIN-04 [余量风控告警]：后台实时监控持仓风险敞口，消耗超阈值时向高管/交易员推送分级告警。（依赖：ZeroBot 定时任务）

### 4.4 管理与行政侧 (Management / PMO)

* F-MGT-01 [统一 Token 网关]：后台分配各部门 AI 额度与可用模型池，原生 API Key 对员工透明。（依赖：ZeroBot 管理台）
* F-MGT-02 [高管一句话看板]：通过微信/iMessage 发送指令，综合 Jira/GitLab 数据汇总项目延期风险。（依赖：ZeroBot IM 互通）
* F-MGT-03 [跨应用灵感捕获]：创作者将全网链接转发给 Bot，自动总结打标并归档至企业知识库(Notion)。（依赖：ZeroBot）

---

## 5. 核心工作流闭环示例 (Standard Operating Procedures - SOP)

场景：量化打板策略的敏捷研发与上线 (投研+研发+风控闭环)

1. 异动触发 (Trigger)：ZeroBot 定时任务抓取到港口吞吐量异常，推送到投资总监微信。
2. 需求下达 (Input)：投资总监在企业 IM 语音输入：“写一个煤炭板块龙头打板策略，带严格止损。”
3. 技术评估 (Probe)：ZeroBot 将指令转化为技术语言，呼叫 CodeCoder `plan` 扫描量化代码库，返回：“已有 MACD 算子，需新增 Leader_Tracker 模块，预计 2 小时。”
4. 极速研发 (Develop)：量化工程师打开 IDE，CodeCoder `build` 已预加载 PRD 上下文，一键生成策略基础代码，工程师微调后 Commit。
5. 沙箱回测 (Test)：ZeroBot 监听到 Commit，自动在沙箱调用回测引擎，生成夏普比率图表回传 IM 群。
6. 人机确认 (HitL)：投资总监在 IM 群点击 [Approve 批准上线] 卡片按钮（Human-in-the-loop 断点）。
7. 实盘与监控 (Monitor)：策略部署，ZeroBot 启动 F-FIN-04 余量监控机制，盯盘并随时准备触发告警。

---

## 6. 非功能性需求与合规标准 (NFR & Compliance)

* NFR-01 [人机协同断点 (HitL)]：涉及代码合并（Merge Request）与实盘交易指令时，系统必须暂停自动化流，生成交互式卡片等待关键角色的 Token/生物识别确认。
* NFR-02 [合规审计轨迹 (Audit Trail)]：ZeroBot 网关层需记录所有输入/输出的 Prompt 哈希值、时间戳、调用人员及使用的路由模型，保留期 > 5 年（满足金融审计要求）。
* NFR-03 [反厂商锁定机制]：引擎层代码必须与底层大模型 API 解耦。支持在无代码修改的情况下，30 秒内通过 ZeroBot 后台将云端模型（如 OpenAI）整体切换为本地开源模型（如 Llama-3 / DeepSeek）。
* NFR-04 [响应性能]：ZeroBot 后台唤醒时间 ≤ 0.5秒；CodeCoder 针对 10 万行级别代码库的 `plan` 扫描分析需在 15 秒内返回初步依赖树。

---
> 免责声明/风险提示：文档中涉及的 `F-FIN` 系列投研与交易功能设计，仅作为 AI 代理能力的系统架构演示。不构成任何真实的投资建议。金融实盘接入需严格遵循当地金融监管法规（如证监会、银保监会相关条例）。

---

### 给使用者的建议

这份 PRD 已经高度模块化。如果你需要让 LLM 进行下一步工作，你可以使用如下 Prompt 配合此文档：

* 如果要写代码：“作为架构师，请读取上述 PRD 的『2. 系统架构设计』和『3. 组件定义』，帮我用 Python/Go 设计 ZeroBot 的核心网关路由类 (Router Class)。”
* 如果要做 UI：“作为产品设计师，请根据『4.4 管理与行政侧』的功能，帮我设计 ZeroBot Web 后台管理大盘的线框图结构，列出需要哪些统计图表。”
* 如果要写测例：“作为 QA，请针对『5. 核心工作流闭环示例』，编写一份端到端的系统测试用例，包含异常分支判断。”
