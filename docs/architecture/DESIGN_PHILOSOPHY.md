# CodeCoder 设计思想

> 生成时间: 2026-02-25

---

## 一、核心设计哲学

### 1.1 祝融说 (Zhu Rong Philosophy)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           祝融说 - 底层认知框架                                      │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│    ┌──────────────────┐                                                             │
│    │  可能性基底      │  宇宙的终极实在是包含一切潜能的无限场域                      │
│    │  (Possibility   │  ──► 代码实现: 多 Agent 并行探索多条路径                      │
│    │   Substrate)    │                                                              │
│    └────────┬─────────┘                                                             │
│             │                                                                        │
│             ▼                                                                        │
│    ┌──────────────────┐                                                             │
│    │  观察即收敛      │  观察是创造性行为，导致可能性"坍缩"为确定性                  │
│    │  (Observation   │  ──► 代码实现: Agent 决策点、用户确认机制                     │
│    │   Collapses)    │                                                              │
│    └────────┬─────────┘                                                             │
│             │                                                                        │
│             ▼                                                                        │
│    ┌──────────────────┐                                                             │
│    │  可用余量        │  尚未被固化的潜能空间，是自由意志和创造力的来源              │
│    │  (Available     │  ──► 代码实现: 回滚机制、Plan Mode、Undo 能力                 │
│    │   Margin)       │                                                              │
│    └────────┬─────────┘                                                             │
│             │                                                                        │
│             ▼                                                                        │
│    ┌──────────────────┐                                                             │
│    │  可持续决策      │  保持"再来一次"的能力比追求"最优解"更重要                    │
│    │  > 最优决策      │  ──► 代码实现: CLOSE 决策框架、风险控制                      │
│    │                  │                                                              │
│    └──────────────────┘                                                             │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 CLOSE 决策框架

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              CLOSE 五维评估法                                        │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   C ─ Capacity       能力匹配度     "我有能力完成这件事吗？"                         │
│   L ─ Leverage       杠杆效应       "投入产出比如何？"                               │
│   O ─ Opportunity    机会成本       "我会错过什么？"                                 │
│   S ─ Sustainability 可持续性       "我能持续做下去吗？" ◄─── 最关键指标            │
│   E ─ Exit           退出路径       "如果失败，我如何全身而退？"                     │
│                                                                                      │
│   ┌────────────────────────────────────────────────────────────────────────────┐   │
│   │  设计原则: 可持续性(S) 是一票否决项，其他四项可以权衡取舍                    │   │
│   │  代码映射: decision Agent 实现此框架，用于职业选择、投资决策等场景          │   │
│   └────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、技术架构设计思想

### 2.1 双语言策略

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           语言选择的设计逻辑                                         │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   ┌─────────────────────────────┐    ┌─────────────────────────────┐               │
│   │     TypeScript (Bun)        │    │        Rust                  │               │
│   ├─────────────────────────────┤    ├─────────────────────────────┤               │
│   │ ✓ AI SDK 生态系统完善       │    │ ✓ 内存安全，无 GC 停顿       │               │
│   │ ✓ 快速迭代 Agent 逻辑       │    │ ✓ 零成本抽象，高性能        │               │
│   │ ✓ JSON/Schema 原生支持      │    │ ✓ 并发安全（所有权系统）    │               │
│   │ ✓ 前后端代码共享            │    │ ✓ 二进制分发，无运行时依赖  │               │
│   ├─────────────────────────────┤    ├─────────────────────────────┤               │
│   │ 应用场景:                   │    │ 应用场景:                   │               │
│   │ • Agent 引擎                │    │ • Gateway 网关              │               │
│   │ • API Server                │    │ • Channels 渠道适配         │               │
│   │ • TUI/Web 界面              │    │ • Workflow 工作流           │               │
│   │ • MCP Server                │    │ • Trading 交易系统          │               │
│   │ • 记忆系统                  │    │ • Browser 浏览器自动化      │               │
│   └─────────────────────────────┘    └─────────────────────────────┘               │
│                                                                                      │
│   ┌────────────────────────────────────────────────────────────────────────────┐   │
│   │  核心原则: "TypeScript 负责智能，Rust 负责安全边界"                          │   │
│   │                                                                              │   │
│   │  TypeScript 处理 AI 调用、Agent 逻辑等需要快速迭代的部分                     │   │
│   │  Rust 处理外部连接、安全敏感操作、高并发场景                                 │   │
│   └────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Agent 系统设计思想

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           Agent 分层架构                                             │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   ┌────────────────────────────────────────────────────────────────────────────┐   │
│   │  设计原则:                                                                   │   │
│   │  1. 单一职责 - 每个 Agent 只做一件事，做到极致                              │   │
│   │  2. 触发器驱动 - 根据输入自动选择最合适的 Agent                             │   │
│   │  3. 可组合 - Agent 之间可以相互调用形成工作流                               │   │
│   │  4. 可扩展 - 支持用户自定义 Agent (prompt + metadata)                       │   │
│   └────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
│   Agent 分类:                                                                       │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐                       │
│   │  工程类 Agent  │  │  领域类 Agent  │  │  思维类 Agent  │                       │
│   ├────────────────┤  ├────────────────┤  ├────────────────┤                       │
│   │ build          │  │ macro          │  │ observer       │                       │
│   │ code-reviewer  │  │ trader         │  │ decision       │                       │
│   │ security-rev   │  │ picker         │  │                │                       │
│   │ tdd-guide      │  │ miniproduct    │  │                │                       │
│   │ architect      │  │ ai-engineer    │  │                │                       │
│   └────────────────┘  └────────────────┘  └────────────────┘                       │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 记忆系统设计思想

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           双层记忆架构 (流 + 沉积)                                   │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   ┌────────────────────────────────────────────────────────────────────────────┐   │
│   │  设计原则:                                                                   │   │
│   │  1. 透明可读 - 纯 Markdown 文件，人类和 AI 都能直接阅读编辑                 │   │
│   │  2. Git 友好 - 所有记忆变更可追溯、可回滚                                   │   │
│   │  3. 无嵌入检索 - 拒绝向量数据库的复杂性，保持简单                           │   │
│   │  4. 分层职责 - 流层记录过程，沉积层记录结论                                 │   │
│   └────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
│   第一层: 每日笔记                         第二层: 长期记忆                         │
│   ─────────────────                        ─────────────────                        │
│   • memory/daily/{YYYY-MM-DD}.md           • memory/MEMORY.md                       │
│   • 仅追加日志                             • 结构化知识                             │
│   • 类比: 河流 (flow)                      • 类比: 沉积岩                            │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、微服务设计思想

### 3.1 Zero Daemon 编排模式

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           进程编排器设计                                             │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   ┌────────────────────────────────────────────────────────────────────────────┐   │
│   │  设计原则:                                                                   │   │
│   │  1. 单一进程入口 - 用户只需启动 daemon，其他服务自动管理                    │   │
│   │  2. 故障自愈 - 子进程崩溃时自动重启，保证高可用                             │   │
│   │  3. 日志聚合 - 所有子进程日志统一收集，便于排查                             │   │
│   │  4. 优雅退出 - 收到 SIGTERM 时，依次停止所有子进程                          │   │
│   └────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
│                        ┌───────────────────────────┐                                │
│                        │     Zero Daemon :4402     │                                │
│                        │      (单一入口点)          │                                │
│                        └─────────────┬─────────────┘                                │
│                                      │                                               │
│          ┌───────────────────────────┼───────────────────────────┐                  │
│          │  spawn                    │ spawn                     │ spawn            │
│          ▼                           ▼                           ▼                  │
│   ┌─────────────┐             ┌─────────────┐             ┌─────────────┐          │
│   │  Gateway    │             │  Channels   │             │  Workflow   │          │
│   │   :4430     │             │   :4431     │             │   :4432     │          │
│   └─────────────┘             └─────────────┘             └─────────────┘          │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Gateway 安全边界设计

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           Gateway 安全分层                                           │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   外部请求 ──► Gateway                                                              │
│                │                                                                     │
│                ├── Layer 1: 认证 (Pairing + JWT)                                    │
│                ├── Layer 2: 授权 (RBAC)                                             │
│                ├── Layer 3: 配额 (Rate Limiting)                                    │
│                └── Layer 4: 审计 (Audit Log)                                        │
│                         │                                                            │
│                         ▼                                                            │
│                    内部服务 (Trusted)                                               │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、Zero Trading 模块设计思想

### 4.1 PO3 + SMT 策略架构

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           Zero Trading 交易系统设计 (开发中)                         │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   策略核心: PO3 (Power of 3) + SMT (Smart Money Technique)                          │
│                                                                                      │
│   PO3 三阶段:                              SMT 背离:                                │
│   ─────────────                            ─────────                                │
│   1. Accumulation (蓄力)                   比较关联品种:                            │
│      横盘整理                              • 沪深300 vs 中证500                      │
│                                            • 上证50 vs 科创50                        │
│   2. Manipulation (假突破)                                                          │
│      诱多/诱空                             看涨背离:                                │
│                                            主品种创新低，参照品种不跟               │
│   3. Distribution (真方向)                                                          │
│      回归中枢                              看跌背离:                                │
│                                            主品种创新高，参照品种不跟               │
│                                                                                      │
│   A股 T+1 规则适配:                                                                 │
│   ──────────────────                                                                │
│   • Day 1: 信号确认后买入 (9:30-10:00 黄金首时 / 14:30-15:00 尾盘)                 │
│   • Day 2: 开盘价评估，决策持有或止损                                               │
│   • 当日买入无法当日卖出 → 必须提前规划止损位                                       │
│                                                                                      │
│   ┌────────────────────────────────────────────────────────────────────────────┐   │
│   │  设计原则:                                                                   │   │
│   │  1. 信号生成与执行分离 - 策略引擎只产出信号，不直接下单                     │   │
│   │  2. 人在回路 (HITL) - 所有交易信号必须经过人工确认                          │   │
│   │  3. 风险优先 - T1RiskControl 模块在任何操作前检查风险                       │   │
│   │  4. 可观测性 - 全链路埋点，每个决策都有日志追溯                             │   │
│   └────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Trading 模块结构

```
zero-trading/
├── src/
│   ├── data/           # 数据层
│   │   ├── tushare.rs  # Tushare API 客户端
│   │   ├── aggregator.rs # 数据聚合器
│   │   └── cache.rs    # 缓存层
│   │
│   ├── strategy/       # 策略层
│   │   ├── po3.rs      # PO3 结构检测
│   │   ├── smt.rs      # SMT 背离检测
│   │   └── signal.rs   # 信号生成
│   │
│   ├── execution/      # 执行层
│   │   ├── position.rs # 仓位管理
│   │   ├── order.rs    # 订单管理
│   │   └── t1_risk.rs  # T+1 风险控制
│   │
│   ├── macro_filter/   # 宏观过滤
│   │   └── mod.rs      # 市场环境过滤
│   │
│   └── routes.rs       # HTTP API
```

---

## 五、设计原则总结

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              核心设计原则                                            │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   1. 确定性 vs 不确定性划分 (底层原则)                                              │
│      "高确定性任务用 zero-* (Rust)，保证效果和效率；                                │
│       高不确定性任务用 ccode (LLM)，保证正确的反应和应对"                           │
│      体现: 协议解析/安全校验 → Rust; 意图理解/代码生成 → LLM                        │
│                                                                                      │
│   2. 可持续性 > 最优性                                                              │
│      "保持再来一次的能力，比追求一次性最优更重要"                                    │
│      体现: 回滚机制、Plan Mode、CLOSE 决策框架                                       │
│                                                                                      │
│   3. 透明可读 > 智能黑盒                                                            │
│      "人类和 AI 都能直接理解系统状态"                                               │
│      体现: Markdown 记忆系统、结构化日志、审计追踪                                   │
│                                                                                      │
│   4. 单一职责 + 可组合                                                              │
│      "每个模块只做一件事，通过组合完成复杂任务"                                      │
│      体现: 23 个专用 Agent、微服务拆分、事件驱动                                     │
│                                                                                      │
│   5. 安全边界在 Rust                                                                │
│      "所有外部输入必须经过 Rust 网关验证"                                           │
│      体现: Gateway 四层安全、Docker 沙箱、RBAC 权限                                  │
│                                                                                      │
│   6. 人在回路 (HITL)                                                                │
│      "关键决策必须有人类确认，自动化服务于人而非替代人"                              │
│      体现: Trading 信号确认、敏感操作二次验证、Plan Mode                             │
│                                                                                      │
│   7. 面向大模型可改写性 (LLM Friendly)                                              │
│      "代码结构让 AI 能够安全、高效地理解和修改"                                      │
│      体现: 一致命名、显式类型、声明式配置、小文件原则                                │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 六、确定性 vs 不确定性深度解析

### 6.1 划分逻辑

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              划分核心逻辑                                            │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│   问题: 如何决定一个任务应该用 Rust (zero-*) 还是 TypeScript/LLM (ccode)?           │
│                                                                                      │
│   答案: 看任务的"确定性程度"                                                        │
│                                                                                      │
│   ┌────────────────────────────┐      ┌────────────────────────────┐               │
│   │  高确定性 → zero-* (Rust)  │      │ 低确定性 → ccode (LLM)     │               │
│   ├────────────────────────────┤      ├────────────────────────────┤               │
│   │ • 输入→输出 可预测         │      │ • 输入→输出 不可预测       │               │
│   │ • 规则明确，无歧义         │      │ • 需要"理解"和"判断"       │               │
│   │ • 错误可枚举               │      │ • 错误难以预料             │               │
│   │ • 性能敏感                 │      │ • 质量敏感                 │               │
│   └────────────────────────────┘      └────────────────────────────┘               │
│                                                                                      │
│   保障手段:                            保障手段:                                    │
│   • 类型系统                           • 大模型能力                                 │
│   • 编译检查                           • Prompt 工程                                │
│   • 单元测试                           • Agent 协作                                 │
│   • 形式化验证                         • 人类反馈                                   │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 与祝融说的深层联系

```
确定性部分 (zero-*) = 已坍缩的可能性 = 规则、协议、约束
不确定性部分 (ccode) = 可用余量 = 创造性、适应性、智能

真正的智慧在于管理可能性的边界，而非追求确定性的最优
```

### 6.3 工程效率最大化

| 任务类型 | 最佳工具 | 原因 |
|---------|---------|------|
| 解析 Telegram 消息格式 | Rust (zero-channels) | 格式固定，需要高性能 |
| 理解用户想要什么 | LLM (ccode) | 自然语言模糊，需要推理 |
| JWT 签名验证 | Rust (zero-gateway) | 算法确定，安全敏感 |
| 生成代码审查建议 | LLM (ccode) | 需要代码理解能力 |
| Cron 表达式解析 | Rust (zero-workflow) | 语法规范明确 |
| 分析宏观经济数据 | LLM (ccode/macro) | 需要领域知识和推理 |

这种划分确保：**每种技术都用在最擅长的地方，实现整体效率最大化。**
