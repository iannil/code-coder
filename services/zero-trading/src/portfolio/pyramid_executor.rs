//! Pyramid Buying Executor.
//!
//! Executes pyramid buying plans by tracking active plans and triggering
//! tranches when price conditions are met.
//!
//! # Workflow
//!
//! 1. Create a PyramidPlan from DipAssessment
//! 2. Register the plan with the executor
//! 3. On each price update, check if any tranches should execute
//! 4. Generate trade orders for triggered tranches
//! 5. Track execution status and remaining budget
//!
//! # Integration
//!
//! ```ignore
//! use zero_trading::portfolio::{PyramidExecutor, PyramidPlan};
//!
//! let executor = PyramidExecutor::new();
//!
//! // Create and register a plan
//! let plan = PyramidPlan::normal("600519", 100_000.0, 150.0, 120.0);
//! executor.register_plan(plan)?;
//!
//! // On price update, check for triggered tranches
//! let orders = executor.check_and_execute("600519", 140.0)?;
//! ```

use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::RwLock;

use super::dip_buying::{PyramidPlan, PyramidStrategy, PyramidTranche};

// ============================================================================
// Trade Order Types
// ============================================================================

/// A trade order generated by the executor.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PyramidOrder {
    /// Unique order ID
    pub order_id: String,
    /// Symbol to buy
    pub symbol: String,
    /// Order side (always Buy for pyramid)
    pub side: OrderSide,
    /// Order type
    pub order_type: OrderType,
    /// Target quantity (shares)
    pub quantity: f64,
    /// Limit price (if applicable)
    pub limit_price: Option<f64>,
    /// Amount to spend (alternative to quantity)
    pub spend_amount: f64,
    /// Tranche index in the plan
    pub tranche_index: usize,
    /// Order timestamp
    pub created_at: DateTime<Utc>,
    /// Order status
    pub status: OrderStatus,
}

/// Order side.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum OrderSide {
    Buy,
    Sell,
}

/// Order type.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum OrderType {
    /// Market order - execute at current price
    Market,
    /// Limit order - execute at limit price or better
    Limit,
    /// Stop limit order
    StopLimit,
}

/// Order status.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum OrderStatus {
    /// Pending submission
    Pending,
    /// Submitted to exchange
    Submitted,
    /// Partially filled
    PartiallyFilled,
    /// Fully filled
    Filled,
    /// Cancelled
    Cancelled,
    /// Rejected
    Rejected,
}

// ============================================================================
// Execution Result
// ============================================================================

/// Result of a tranche execution check.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionResult {
    /// Orders generated
    pub orders: Vec<PyramidOrder>,
    /// Plans that were updated
    pub updated_plans: Vec<String>,
    /// Any errors encountered
    pub errors: Vec<String>,
    /// Timestamp
    pub checked_at: DateTime<Utc>,
}

impl ExecutionResult {
    fn empty() -> Self {
        Self {
            orders: Vec::new(),
            updated_plans: Vec::new(),
            errors: Vec::new(),
            checked_at: Utc::now(),
        }
    }
}

// ============================================================================
// Pyramid Executor Configuration
// ============================================================================

/// Configuration for pyramid executor.
#[derive(Debug, Clone)]
pub struct PyramidExecutorConfig {
    /// Use limit orders instead of market orders
    pub use_limit_orders: bool,
    /// Limit order offset from current price (%)
    pub limit_order_offset_pct: f64,
    /// Auto-cancel expired plans
    pub auto_cancel_expired: bool,
    /// Maximum concurrent plans per symbol
    pub max_plans_per_symbol: usize,
}

impl Default for PyramidExecutorConfig {
    fn default() -> Self {
        Self {
            use_limit_orders: true,
            limit_order_offset_pct: 0.5, // 0.5% above current price
            auto_cancel_expired: true,
            max_plans_per_symbol: 1, // Only one plan per symbol
        }
    }
}

// ============================================================================
// Pyramid Executor
// ============================================================================

/// Executor for pyramid buying plans.
pub struct PyramidExecutor {
    /// Active pyramid plans (symbol -> plan)
    plans: RwLock<HashMap<String, PyramidPlan>>,
    /// Configuration
    config: PyramidExecutorConfig,
    /// Order counter for ID generation
    order_counter: RwLock<u64>,
}

impl PyramidExecutor {
    /// Create a new executor with default config.
    pub fn new() -> Self {
        Self {
            plans: RwLock::new(HashMap::new()),
            config: PyramidExecutorConfig::default(),
            order_counter: RwLock::new(0),
        }
    }

    /// Create with custom config.
    pub fn with_config(config: PyramidExecutorConfig) -> Self {
        Self {
            plans: RwLock::new(HashMap::new()),
            config,
            order_counter: RwLock::new(0),
        }
    }

    /// Register a new pyramid plan.
    ///
    /// Returns error if a plan already exists for this symbol and
    /// max_plans_per_symbol is exceeded.
    pub fn register_plan(&self, plan: PyramidPlan) -> Result<(), String> {
        let mut plans = self
            .plans
            .write()
            .map_err(|_| "Failed to acquire lock".to_string())?;

        // Check if plan already exists
        if plans.contains_key(&plan.symbol) {
            return Err(format!(
                "Plan already exists for {}. Cancel existing plan first.",
                plan.symbol
            ));
        }

        // Validate plan
        if plan.tranches.is_empty() {
            return Err("Plan has no tranches".to_string());
        }
        if plan.total_budget <= 0.0 {
            return Err("Plan budget must be positive".to_string());
        }

        plans.insert(plan.symbol.clone(), plan);
        Ok(())
    }

    /// Cancel and remove a plan.
    pub fn cancel_plan(&self, symbol: &str) -> Result<Option<PyramidPlan>, String> {
        let mut plans = self
            .plans
            .write()
            .map_err(|_| "Failed to acquire lock".to_string())?;

        Ok(plans.remove(symbol))
    }

    /// Get a plan by symbol.
    pub fn get_plan(&self, symbol: &str) -> Option<PyramidPlan> {
        self.plans
            .read()
            .ok()
            .and_then(|plans| plans.get(symbol).cloned())
    }

    /// Get all active plans.
    pub fn get_all_plans(&self) -> Vec<PyramidPlan> {
        self.plans
            .read()
            .ok()
            .map(|plans| plans.values().cloned().collect())
            .unwrap_or_default()
    }

    /// Check if any tranches should execute and generate orders.
    ///
    /// This should be called on each price update for monitored symbols.
    pub fn check_and_execute(&self, symbol: &str, current_price: f64) -> ExecutionResult {
        let mut result = ExecutionResult::empty();

        // Get write lock to update plan
        let mut plans = match self.plans.write() {
            Ok(p) => p,
            Err(_) => {
                result.errors.push("Failed to acquire lock".to_string());
                return result;
            }
        };

        let plan = match plans.get_mut(symbol) {
            Some(p) => p,
            None => return result, // No plan for this symbol
        };

        // Check if plan is expired
        if plan.is_expired() {
            if self.config.auto_cancel_expired {
                plans.remove(symbol);
                result.errors.push(format!("Plan for {} expired and was removed", symbol));
            } else {
                result.errors.push(format!("Plan for {} is expired", symbol));
            }
            return result;
        }

        // Find tranches that should execute
        let triggered_tranches: Vec<usize> = plan
            .tranches
            .iter()
            .enumerate()
            .filter(|(_, t)| self.should_execute_tranche(t, current_price))
            .map(|(i, _)| i)
            .collect();

        // Generate orders for triggered tranches
        for tranche_idx in triggered_tranches {
            let tranche = &plan.tranches[tranche_idx];
            let spend_amount = plan.total_budget * (tranche.allocation_pct / 100.0);

            let order = self.create_order(symbol, spend_amount, current_price, tranche_idx);
            result.orders.push(order);

            // Mark tranche as executed
            plan.tranches[tranche_idx].executed = true;
            plan.tranches[tranche_idx].executed_at = Some(Utc::now());
        }

        // Check if plan is complete (all tranches executed)
        let all_executed = plan.tranches.iter().all(|t| t.executed);
        if all_executed {
            plans.remove(symbol);
            result.updated_plans.push(format!("{} (completed)", symbol));
        } else if !result.orders.is_empty() {
            result.updated_plans.push(symbol.to_string());
        }

        result
    }

    /// Check all plans against provided prices.
    pub fn check_all(&self, prices: &HashMap<String, f64>) -> ExecutionResult {
        let mut combined_result = ExecutionResult::empty();

        // Get list of symbols first to avoid holding lock during iteration
        let symbols: Vec<String> = self
            .plans
            .read()
            .ok()
            .map(|plans| plans.keys().cloned().collect())
            .unwrap_or_default();

        for symbol in symbols {
            if let Some(&price) = prices.get(&symbol) {
                let result = self.check_and_execute(&symbol, price);
                combined_result.orders.extend(result.orders);
                combined_result.updated_plans.extend(result.updated_plans);
                combined_result.errors.extend(result.errors);
            }
        }

        combined_result
    }

    /// Check if a tranche should execute.
    fn should_execute_tranche(&self, tranche: &PyramidTranche, current_price: f64) -> bool {
        // Already executed
        if tranche.executed {
            return false;
        }

        // Price condition: current price at or below trigger
        if current_price > tranche.trigger_price {
            return false;
        }

        // Time interval check (if previously executed tranches exist)
        // Note: This is handled at plan level in a full implementation
        // For now, we just check the price condition

        true
    }

    /// Create an order for a tranche.
    fn create_order(
        &self,
        symbol: &str,
        spend_amount: f64,
        current_price: f64,
        tranche_index: usize,
    ) -> PyramidOrder {
        let order_id = self.next_order_id();

        let (order_type, limit_price) = if self.config.use_limit_orders {
            let limit = current_price * (1.0 + self.config.limit_order_offset_pct / 100.0);
            (OrderType::Limit, Some(limit))
        } else {
            (OrderType::Market, None)
        };

        // Calculate quantity based on limit or market price
        let price_for_calc = limit_price.unwrap_or(current_price);
        let quantity = spend_amount / price_for_calc;

        PyramidOrder {
            order_id,
            symbol: symbol.to_string(),
            side: OrderSide::Buy,
            order_type,
            quantity,
            limit_price,
            spend_amount,
            tranche_index,
            created_at: Utc::now(),
            status: OrderStatus::Pending,
        }
    }

    /// Generate next order ID.
    fn next_order_id(&self) -> String {
        let mut counter = self.order_counter.write().unwrap();
        *counter += 1;
        format!("PYR-{:08}", *counter)
    }

    /// Get execution statistics.
    pub fn get_stats(&self) -> ExecutorStats {
        let plans = self.plans.read().unwrap();

        let total_plans = plans.len();
        let mut total_tranches = 0;
        let mut executed_tranches = 0;
        let mut total_budget = 0.0;
        let mut remaining_budget = 0.0;

        for plan in plans.values() {
            total_budget += plan.total_budget;
            remaining_budget += plan.remaining_budget();
            for tranche in &plan.tranches {
                total_tranches += 1;
                if tranche.executed {
                    executed_tranches += 1;
                }
            }
        }

        ExecutorStats {
            active_plans: total_plans,
            total_tranches,
            executed_tranches,
            pending_tranches: total_tranches - executed_tranches,
            total_budget_allocated: total_budget,
            remaining_budget,
            execution_rate: if total_tranches > 0 {
                (executed_tranches as f64 / total_tranches as f64) * 100.0
            } else {
                0.0
            },
        }
    }
}

impl Default for PyramidExecutor {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// Executor Statistics
// ============================================================================

/// Statistics about the executor's current state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutorStats {
    /// Number of active plans
    pub active_plans: usize,
    /// Total number of tranches across all plans
    pub total_tranches: usize,
    /// Number of executed tranches
    pub executed_tranches: usize,
    /// Number of pending tranches
    pub pending_tranches: usize,
    /// Total budget allocated across all plans
    pub total_budget_allocated: f64,
    /// Remaining budget to be deployed
    pub remaining_budget: f64,
    /// Execution rate (%)
    pub execution_rate: f64,
}

// ============================================================================
// Plan Builder
// ============================================================================

/// Builder for creating custom pyramid plans.
pub struct PyramidPlanBuilder {
    symbol: String,
    strategy: PyramidStrategy,
    total_budget: f64,
    tranches: Vec<PyramidTranche>,
    expires_in_days: i64,
}

impl PyramidPlanBuilder {
    /// Create a new plan builder.
    pub fn new(symbol: &str, total_budget: f64) -> Self {
        Self {
            symbol: symbol.to_string(),
            strategy: PyramidStrategy::Normal,
            total_budget,
            tranches: Vec::new(),
            expires_in_days: 90,
        }
    }

    /// Set the strategy type.
    pub fn strategy(mut self, strategy: PyramidStrategy) -> Self {
        self.strategy = strategy;
        self
    }

    /// Add a tranche.
    pub fn add_tranche(
        mut self,
        trigger_price: f64,
        allocation_pct: f64,
        min_interval_days: u32,
    ) -> Self {
        self.tranches.push(PyramidTranche {
            trigger_price,
            allocation_pct,
            min_interval_days,
            executed: false,
            executed_at: None,
        });
        self
    }

    /// Set expiration period in days.
    pub fn expires_in(mut self, days: i64) -> Self {
        self.expires_in_days = days;
        self
    }

    /// Build the plan.
    pub fn build(self) -> Result<PyramidPlan, String> {
        // Validate allocations sum to 100%
        let total_allocation: f64 = self.tranches.iter().map(|t| t.allocation_pct).sum();
        if (total_allocation - 100.0).abs() > 0.01 {
            return Err(format!(
                "Tranche allocations must sum to 100%, got {:.2}%",
                total_allocation
            ));
        }

        if self.tranches.is_empty() {
            return Err("Plan must have at least one tranche".to_string());
        }

        Ok(PyramidPlan {
            symbol: self.symbol,
            strategy: self.strategy,
            total_budget: self.total_budget,
            tranches: self.tranches,
            created_at: Utc::now(),
            expires_at: Utc::now() + Duration::days(self.expires_in_days),
        })
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_register_plan() {
        let executor = PyramidExecutor::new();
        let plan = PyramidPlan::normal("TEST", 100_000.0, 100.0, 80.0);

        let result = executor.register_plan(plan);
        assert!(result.is_ok());

        // Should fail for duplicate
        let plan2 = PyramidPlan::normal("TEST", 50_000.0, 100.0, 80.0);
        let result2 = executor.register_plan(plan2);
        assert!(result2.is_err());
    }

    #[test]
    fn test_execute_tranche() {
        let executor = PyramidExecutor::new();
        let plan = PyramidPlan::normal("TEST", 100_000.0, 100.0, 80.0);
        executor.register_plan(plan).unwrap();

        // Price at trigger level should execute first tranche
        let result = executor.check_and_execute("TEST", 100.0);

        assert_eq!(result.orders.len(), 1);
        assert_eq!(result.orders[0].symbol, "TEST");
        assert!(result.orders[0].spend_amount > 0.0);
    }

    #[test]
    fn test_no_execution_above_trigger() {
        let executor = PyramidExecutor::new();
        let plan = PyramidPlan::normal("TEST", 100_000.0, 100.0, 80.0);
        executor.register_plan(plan).unwrap();

        // Price above first trigger should not execute
        let result = executor.check_and_execute("TEST", 105.0);

        assert!(result.orders.is_empty());
    }

    #[test]
    fn test_multiple_tranches() {
        let executor = PyramidExecutor::new();
        let plan = PyramidPlan::normal("TEST", 100_000.0, 100.0, 80.0);
        executor.register_plan(plan).unwrap();

        // Execute first tranche at 100
        let result1 = executor.check_and_execute("TEST", 100.0);
        assert_eq!(result1.orders.len(), 1);

        // Execute second tranche at lower price (next trigger is ~95)
        let result2 = executor.check_and_execute("TEST", 94.0);
        assert_eq!(result2.orders.len(), 1);

        // Check stats
        let stats = executor.get_stats();
        assert_eq!(stats.executed_tranches, 2);
        assert_eq!(stats.pending_tranches, 2);
    }

    #[test]
    fn test_plan_builder() {
        let plan = PyramidPlanBuilder::new("TEST", 100_000.0)
            .strategy(PyramidStrategy::Equal)
            .add_tranche(100.0, 25.0, 0)
            .add_tranche(95.0, 25.0, 7)
            .add_tranche(90.0, 25.0, 14)
            .add_tranche(85.0, 25.0, 21)
            .expires_in(60)
            .build();

        assert!(plan.is_ok());
        let plan = plan.unwrap();
        assert_eq!(plan.strategy, PyramidStrategy::Equal);
        assert_eq!(plan.tranches.len(), 4);
    }

    #[test]
    fn test_plan_builder_validation() {
        let plan = PyramidPlanBuilder::new("TEST", 100_000.0)
            .add_tranche(100.0, 50.0, 0)
            .add_tranche(90.0, 30.0, 7)
            // Total only 80%, should fail
            .build();

        assert!(plan.is_err());
    }

    #[test]
    fn test_cancel_plan() {
        let executor = PyramidExecutor::new();
        let plan = PyramidPlan::normal("TEST", 100_000.0, 100.0, 80.0);
        executor.register_plan(plan).unwrap();

        let cancelled = executor.cancel_plan("TEST").unwrap();
        assert!(cancelled.is_some());

        // Should be gone
        assert!(executor.get_plan("TEST").is_none());
    }

    #[test]
    fn test_executor_stats() {
        let executor = PyramidExecutor::new();
        executor
            .register_plan(PyramidPlan::normal("A", 50_000.0, 100.0, 80.0))
            .unwrap();
        executor
            .register_plan(PyramidPlan::normal("B", 50_000.0, 100.0, 80.0))
            .unwrap();

        let stats = executor.get_stats();
        assert_eq!(stats.active_plans, 2);
        assert_eq!(stats.total_tranches, 8); // 4 tranches per plan
        assert_eq!(stats.executed_tranches, 0);
        assert!((stats.total_budget_allocated - 100_000.0).abs() < 0.01);
    }

    #[test]
    fn test_order_id_generation() {
        let executor = PyramidExecutor::new();

        let id1 = executor.next_order_id();
        let id2 = executor.next_order_id();

        assert_ne!(id1, id2);
        assert!(id1.starts_with("PYR-"));
    }

    #[test]
    fn test_check_all_plans() {
        let executor = PyramidExecutor::new();
        executor
            .register_plan(PyramidPlan::normal("A", 50_000.0, 100.0, 80.0))
            .unwrap();
        executor
            .register_plan(PyramidPlan::normal("B", 50_000.0, 200.0, 160.0))
            .unwrap();

        let mut prices = HashMap::new();
        prices.insert("A".to_string(), 100.0); // At trigger
        prices.insert("B".to_string(), 210.0); // Above trigger

        let result = executor.check_all(&prices);

        // Only A should trigger
        assert_eq!(result.orders.len(), 1);
        assert_eq!(result.orders[0].symbol, "A");
    }
}
