//! Trading signal types.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::data::Timeframe;
use super::{Po3Structure, SmtDivergence};

/// Trading signal direction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SignalDirection {
    /// Buy/Long signal
    Long,
    /// Sell/Short signal (or avoid buying for T+1)
    Short,
}

/// Signal strength indicator
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum SignalStrength {
    /// Single confluence, low confidence
    Weak,
    /// 2-3 confluences
    Medium,
    /// Multiple confluences, high confidence
    Strong,
    /// All confluences aligned
    VeryStrong,
}

/// A trading signal generated by the strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingSignal {
    /// Unique signal ID
    pub id: String,
    /// Symbol to trade
    pub symbol: String,
    /// Trade direction
    pub direction: SignalDirection,
    /// Signal strength
    pub strength: SignalStrength,
    /// Suggested entry price
    pub entry_price: f64,
    /// Stop loss price
    pub stop_loss: f64,
    /// Take profit target (usually 50% midpoint)
    pub take_profit: f64,
    /// Timestamp of signal generation
    pub timestamp: DateTime<Utc>,
    /// Underlying PO3 structure (if detected)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub po3_structure: Option<Po3Structure>,
    /// SMT divergence (if detected)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smt_divergence: Option<SmtDivergence>,
    /// Timeframes that showed alignment
    pub timeframe_alignment: Vec<Timeframe>,
    /// Human-readable notes
    pub notes: String,
}

impl TradingSignal {
    /// Calculate risk/reward ratio
    pub fn risk_reward(&self) -> f64 {
        let risk = (self.entry_price - self.stop_loss).abs();
        let reward = (self.take_profit - self.entry_price).abs();

        if risk > 0.0 {
            reward / risk
        } else {
            0.0
        }
    }

    /// Calculate risk percentage from entry
    pub fn risk_percent(&self) -> f64 {
        let risk = (self.entry_price - self.stop_loss).abs();
        (risk / self.entry_price) * 100.0
    }

    /// Calculate potential reward percentage from entry
    pub fn reward_percent(&self) -> f64 {
        let reward = (self.take_profit - self.entry_price).abs();
        (reward / self.entry_price) * 100.0
    }

    /// Check if signal is still valid (not expired)
    pub fn is_valid(&self, expiry_minutes: i64) -> bool {
        let age = Utc::now().signed_duration_since(self.timestamp);
        age.num_minutes() < expiry_minutes
    }

    /// Get a brief summary for notifications
    pub fn summary(&self) -> String {
        let dir = match self.direction {
            SignalDirection::Long => "ÂÅöÂ§ö",
            SignalDirection::Short => "ÂÅöÁ©∫",
        };
        let strength = match self.strength {
            SignalStrength::Weak => "Âº±",
            SignalStrength::Medium => "‰∏≠",
            SignalStrength::Strong => "Âº∫",
            SignalStrength::VeryStrong => "ÊûÅÂº∫",
        };

        format!(
            "{} {} | Âº∫Â∫¶:{} | ÂÖ•Âú∫:{:.2} Ê≠¢Êçü:{:.2} ÁõÆÊ†á:{:.2} | R:R={:.1}:1",
            self.symbol,
            dir,
            strength,
            self.entry_price,
            self.stop_loss,
            self.take_profit,
            self.risk_reward()
        )
    }

    /// Generate Telegram-formatted message
    pub fn to_telegram_message(&self) -> String {
        let dir_emoji = match self.direction {
            SignalDirection::Long => "üü¢",
            SignalDirection::Short => "üî¥",
        };
        let strength_stars = match self.strength {
            SignalStrength::Weak => "‚≠ê",
            SignalStrength::Medium => "‚≠ê‚≠ê",
            SignalStrength::Strong => "‚≠ê‚≠ê‚≠ê",
            SignalStrength::VeryStrong => "‚≠ê‚≠ê‚≠ê‚≠ê",
        };

        let tfs = self.timeframe_alignment.iter()
            .map(|tf| tf.to_string())
            .collect::<Vec<_>>()
            .join(", ");

        let mut msg = format!(
            "{} *{}* {}\n\n\
            üìä *‰ø°Âè∑Âº∫Â∫¶:* {}\n\
            üí∞ *ÂÖ•Âú∫‰ª∑:* {:.2}\n\
            üõë *Ê≠¢Êçü:* {:.2} ({:.1}%)\n\
            üéØ *ÁõÆÊ†á:* {:.2} ({:.1}%)\n\
            üìà *È£éÈô©ÂõûÊä•:* {:.1}:1\n\
            ‚è∞ *Âë®ÊúüÂÖ±ÊåØ:* {}\n",
            dir_emoji,
            self.symbol,
            match self.direction {
                SignalDirection::Long => "ÂÅöÂ§ö‰ø°Âè∑",
                SignalDirection::Short => "ÂÅöÁ©∫/ËßÇÊúõ",
            },
            strength_stars,
            self.entry_price,
            self.stop_loss,
            self.risk_percent(),
            self.take_profit,
            self.reward_percent(),
            self.risk_reward(),
            tfs
        );

        // Add PO3 info
        if let Some(ref po3) = self.po3_structure {
            msg.push_str(&format!(
                "\nüìê *PO3ÁªìÊûÑ:*\n\
                  - Èò∂ÊÆµ: {:?}\n\
                  - ‰∏≠ËΩ¥Á∫ø: {:.2}\n",
                po3.current_phase,
                po3.midpoint
            ));
        }

        // Add SMT info
        if let Some(ref smt) = self.smt_divergence {
            msg.push_str(&format!(
                "\nüîÑ *SMTËÉåÁ¶ª:*\n\
                  - Á±ªÂûã: {:?}\n\
                  - Âº∫Â∫¶: {}%\n",
                smt.divergence_type,
                smt.strength
            ));
        }

        // Add notes
        if !self.notes.is_empty() {
            msg.push_str(&format!("\nüìù {}", self.notes));
        }

        msg.push_str(&format!(
            "\n\n‚è± {}",
            self.timestamp.format("%Y-%m-%d %H:%M")
        ));

        msg
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn make_test_signal() -> TradingSignal {
        TradingSignal {
            id: "test-1".to_string(),
            symbol: "000001.SZ".to_string(),
            direction: SignalDirection::Long,
            strength: SignalStrength::Strong,
            entry_price: 10.0,
            stop_loss: 9.5,
            take_profit: 11.0,
            timestamp: Utc::now(),
            po3_structure: None,
            smt_divergence: None,
            timeframe_alignment: vec![Timeframe::Daily, Timeframe::H4],
            notes: "Test signal".to_string(),
        }
    }

    #[test]
    fn test_risk_reward() {
        let signal = make_test_signal();
        let rr = signal.risk_reward();

        // Risk: 10 - 9.5 = 0.5
        // Reward: 11 - 10 = 1.0
        // R:R = 2:1
        assert!((rr - 2.0).abs() < 0.01);
    }

    #[test]
    fn test_risk_percent() {
        let signal = make_test_signal();
        let risk = signal.risk_percent();

        // Risk: 0.5 / 10 * 100 = 5%
        assert!((risk - 5.0).abs() < 0.01);
    }

    #[test]
    fn test_summary() {
        let signal = make_test_signal();
        let summary = signal.summary();

        assert!(summary.contains("000001.SZ"));
        assert!(summary.contains("ÂÅöÂ§ö"));
        assert!(summary.contains("Âº∫"));
    }

    #[test]
    fn test_telegram_message() {
        let signal = make_test_signal();
        let msg = signal.to_telegram_message();

        assert!(msg.contains("üü¢"));
        assert!(msg.contains("000001.SZ"));
        assert!(msg.contains("ÂÖ•Âú∫‰ª∑"));
        assert!(msg.contains("Ê≠¢Êçü"));
    }

    #[test]
    fn test_signal_validity() {
        let signal = make_test_signal();
        assert!(signal.is_valid(60)); // Valid within 60 minutes
    }
}
