//! Economic data monitoring bridge.
//!
//! Fetches high-frequency economic indicators from APIs,
//! detects anomalies, and pushes alerts to IM channels.

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Duration;

// ============================================================================
// Types
// ============================================================================

/// Economic indicator type.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum IndicatorType {
    /// Consumer Price Index
    Cpi,
    /// Producer Price Index
    Ppi,
    /// Gross Domestic Product
    Gdp,
    /// Purchasing Managers' Index
    Pmi,
    /// Interest Rate
    InterestRate,
    /// Unemployment Rate
    Unemployment,
    /// Industrial Production
    IndustrialProduction,
    /// Retail Sales
    RetailSales,
    /// Money Supply M2
    M2,
    /// Social Financing
    SocialFinancing,
    /// Fixed Asset Investment (new)
    FixedAssetInvestment,
    /// Export Year-over-Year (new)
    ExportYoy,
    /// Import Year-over-Year (new)
    ImportYoy,
    /// Loan Prime Rate (new)
    Lpr,
    /// Medium-term Lending Facility Rate (new)
    MlfRate,
    /// Custom indicator
    Custom,
}

impl std::fmt::Display for IndicatorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Cpi => write!(f, "CPI"),
            Self::Ppi => write!(f, "PPI"),
            Self::Gdp => write!(f, "GDP"),
            Self::Pmi => write!(f, "PMI"),
            Self::InterestRate => write!(f, "Interest Rate"),
            Self::Unemployment => write!(f, "Unemployment"),
            Self::IndustrialProduction => write!(f, "Industrial Production"),
            Self::RetailSales => write!(f, "Retail Sales"),
            Self::M2 => write!(f, "M2"),
            Self::SocialFinancing => write!(f, "Social Financing"),
            Self::FixedAssetInvestment => write!(f, "Fixed Asset Investment"),
            Self::ExportYoy => write!(f, "Export YoY"),
            Self::ImportYoy => write!(f, "Import YoY"),
            Self::Lpr => write!(f, "LPR"),
            Self::MlfRate => write!(f, "MLF Rate"),
            Self::Custom => write!(f, "Custom"),
        }
    }
}

/// Data source for economic indicators.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum DataSource {
    /// Federal Reserve Economic Data
    Fred,
    /// Alpha Vantage
    AlphaVantage,
    /// National Bureau of Statistics of China
    NbsChina,
    /// Custom API
    Custom,
}

/// A single economic data point.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EconomicDataPoint {
    /// Indicator type
    pub indicator: IndicatorType,
    /// Data source
    pub source: DataSource,
    /// Country/region code
    pub country: String,
    /// Value
    pub value: f64,
    /// Previous value (for comparison)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_value: Option<f64>,
    /// Year-over-year change percentage
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yoy_change: Option<f64>,
    /// Month-over-month change percentage
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mom_change: Option<f64>,
    /// Data timestamp (release date)
    pub timestamp: DateTime<Utc>,
    /// Fetch timestamp
    pub fetched_at: DateTime<Utc>,
    /// Unit (e.g., "%", "billions USD")
    pub unit: String,
}

/// Anomaly detection result.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnomalyAlert {
    /// Alert ID
    pub id: String,
    /// Indicator that triggered the alert
    pub indicator: IndicatorType,
    /// Country/region
    pub country: String,
    /// Alert type
    pub alert_type: AlertType,
    /// Severity (1-5, 5 being most severe)
    pub severity: u8,
    /// Current value
    pub current_value: f64,
    /// Expected value (or threshold)
    pub expected_value: f64,
    /// Deviation percentage
    pub deviation_percent: f64,
    /// Alert message
    pub message: String,
    /// Analysis (generated by LLM if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis: Option<String>,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
}

/// Type of anomaly alert.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum AlertType {
    /// Value above expected threshold
    AboveThreshold,
    /// Value below expected threshold
    BelowThreshold,
    /// Significant change from previous period
    SignificantChange,
    /// Trend reversal
    TrendReversal,
    /// Data release (new data available)
    DataRelease,
}

/// Configuration for an indicator to monitor.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndicatorConfig {
    /// Indicator type
    pub indicator: IndicatorType,
    /// Data source
    pub source: DataSource,
    /// Country/region code
    pub country: String,
    /// Custom API endpoint (for Custom source)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_endpoint: Option<String>,
    /// High threshold for alerting
    #[serde(skip_serializing_if = "Option::is_none")]
    pub high_threshold: Option<f64>,
    /// Low threshold for alerting
    #[serde(skip_serializing_if = "Option::is_none")]
    pub low_threshold: Option<f64>,
    /// Change percentage threshold for alerting
    #[serde(default = "default_change_threshold")]
    pub change_threshold: f64,
}

fn default_change_threshold() -> f64 {
    5.0 // 5% change triggers alert by default
}

// ============================================================================
// Economic Data Bridge
// ============================================================================

/// Bridge for economic data monitoring.
pub struct EconomicDataBridge {
    /// HTTP client
    client: reqwest::Client,
    /// CodeCoder API endpoint (for LLM analysis)
    #[allow(dead_code)] // Reserved for future LLM integration
    codecoder_endpoint: String,
    /// API keys for different sources
    api_keys: HashMap<String, String>,
    /// Data history (for anomaly detection)
    history: Arc<tokio::sync::RwLock<HashMap<String, Vec<EconomicDataPoint>>>>,
    /// Alert history
    alerts: Arc<tokio::sync::RwLock<Vec<AnomalyAlert>>>,
    /// Channels endpoint for notifications
    channels_endpoint: Option<String>,
}

impl EconomicDataBridge {
    /// Create a new economic data bridge.
    pub fn new(codecoder_endpoint: impl Into<String>) -> Self {
        let client = reqwest::Client::builder()
            .timeout(Duration::from_secs(30))
            .build()
            .unwrap_or_else(|_| reqwest::Client::new());

        Self {
            client,
            codecoder_endpoint: codecoder_endpoint.into(),
            api_keys: HashMap::new(),
            history: Arc::new(tokio::sync::RwLock::new(HashMap::new())),
            alerts: Arc::new(tokio::sync::RwLock::new(Vec::new())),
            channels_endpoint: None,
        }
    }

    /// Set API key for a data source.
    pub fn with_api_key(mut self, source: &str, key: impl Into<String>) -> Self {
        self.api_keys.insert(source.to_string(), key.into());
        self
    }

    /// Set channels endpoint for notifications.
    pub fn with_channels_endpoint(mut self, endpoint: impl Into<String>) -> Self {
        self.channels_endpoint = Some(endpoint.into());
        self
    }

    /// Fetch and check indicators.
    pub async fn check_indicators(
        &self,
        configs: &[IndicatorConfig],
    ) -> Result<Vec<AnomalyAlert>> {
        let mut alerts = Vec::new();

        for config in configs {
            match self.fetch_indicator(config).await {
                Ok(data_point) => {
                    // Store in history
                    self.store_data_point(&data_point).await;

                    // Check for anomalies
                    if let Some(alert) = self.detect_anomaly(config, &data_point).await {
                        alerts.push(alert.clone());
                        self.store_alert(&alert).await;
                    }
                }
                Err(e) => {
                    tracing::warn!(
                        indicator = ?config.indicator,
                        error = %e,
                        "Failed to fetch indicator"
                    );
                }
            }
        }

        Ok(alerts)
    }

    /// Fetch a single indicator.
    async fn fetch_indicator(&self, config: &IndicatorConfig) -> Result<EconomicDataPoint> {
        match config.source {
            DataSource::Fred => self.fetch_from_fred(config).await,
            DataSource::AlphaVantage => self.fetch_from_alpha_vantage(config).await,
            DataSource::NbsChina => self.fetch_from_nbs_china(config).await,
            DataSource::Custom => self.fetch_from_custom(config).await,
        }
    }

    /// Fetch from FRED API.
    async fn fetch_from_fred(&self, config: &IndicatorConfig) -> Result<EconomicDataPoint> {
        let api_key = self
            .api_keys
            .get("fred")
            .context("FRED API key not configured")?;

        let series_id = match config.indicator {
            IndicatorType::Cpi => "CPIAUCSL",
            IndicatorType::Ppi => "PPIACO",
            IndicatorType::Gdp => "GDP",
            IndicatorType::Unemployment => "UNRATE",
            IndicatorType::InterestRate => "FEDFUNDS",
            IndicatorType::IndustrialProduction => "INDPRO",
            IndicatorType::RetailSales => "RSXFS",
            IndicatorType::M2 => "M2SL",
            _ => return Err(anyhow::anyhow!("Indicator not supported by FRED")),
        };

        let url = format!(
            "https://api.stlouisfed.org/fred/series/observations?series_id={}&api_key={}&file_type=json&sort_order=desc&limit=2",
            series_id, api_key
        );

        let response: FredResponse = self
            .client
            .get(&url)
            .send()
            .await
            .context("Failed to fetch from FRED")?
            .json()
            .await
            .context("Failed to parse FRED response")?;

        if response.observations.is_empty() {
            return Err(anyhow::anyhow!("No observations returned from FRED"));
        }

        let latest = &response.observations[0];
        let previous = response.observations.get(1);

        let value: f64 = latest.value.parse().context("Failed to parse value")?;
        let previous_value = previous
            .and_then(|p| p.value.parse::<f64>().ok());

        let mom_change = previous_value.map(|pv| ((value - pv) / pv) * 100.0);

        Ok(EconomicDataPoint {
            indicator: config.indicator,
            source: DataSource::Fred,
            country: "US".to_string(),
            value,
            previous_value,
            yoy_change: None, // Would need more historical data
            mom_change,
            timestamp: chrono::DateTime::parse_from_str(&format!("{} 00:00:00 +0000", latest.date), "%Y-%m-%d %H:%M:%S %z")
                .map(|dt| dt.with_timezone(&Utc))
                .unwrap_or_else(|_| Utc::now()),
            fetched_at: Utc::now(),
            unit: "%".to_string(),
        })
    }

    /// Fetch from Alpha Vantage API.
    async fn fetch_from_alpha_vantage(&self, config: &IndicatorConfig) -> Result<EconomicDataPoint> {
        let api_key = self
            .api_keys
            .get("alpha_vantage")
            .context("Alpha Vantage API key not configured")?;

        let function = match config.indicator {
            IndicatorType::Cpi => "CPI",
            IndicatorType::Unemployment => "UNEMPLOYMENT",
            IndicatorType::InterestRate => "FEDERAL_FUNDS_RATE",
            IndicatorType::Gdp => "REAL_GDP",
            IndicatorType::RetailSales => "RETAIL_SALES",
            _ => return Err(anyhow::anyhow!("Indicator not supported by Alpha Vantage")),
        };

        let url = format!(
            "https://www.alphavantage.co/query?function={}&apikey={}",
            function, api_key
        );

        let response: AlphaVantageResponse = self
            .client
            .get(&url)
            .send()
            .await
            .context("Failed to fetch from Alpha Vantage")?
            .json()
            .await
            .context("Failed to parse Alpha Vantage response")?;

        if response.data.is_empty() {
            return Err(anyhow::anyhow!("No data returned from Alpha Vantage"));
        }

        let latest = &response.data[0];
        let previous = response.data.get(1);

        let value: f64 = latest.value.parse().context("Failed to parse value")?;
        let previous_value = previous.and_then(|p| p.value.parse::<f64>().ok());
        let mom_change = previous_value.map(|pv| ((value - pv) / pv) * 100.0);

        Ok(EconomicDataPoint {
            indicator: config.indicator,
            source: DataSource::AlphaVantage,
            country: "US".to_string(),
            value,
            previous_value,
            yoy_change: None,
            mom_change,
            timestamp: chrono::DateTime::parse_from_str(&format!("{} 00:00:00 +0000", latest.date), "%Y-%m-%d %H:%M:%S %z")
                .map(|dt| dt.with_timezone(&Utc))
                .unwrap_or_else(|_| Utc::now()),
            fetched_at: Utc::now(),
            unit: response.unit.unwrap_or_else(|| "%".to_string()),
        })
    }

    /// Fetch from NBS China (National Bureau of Statistics).
    ///
    /// Since NBS doesn't have a public REST API, we use a proxy approach:
    /// 1. Check cached data first
    /// 2. Try third-party data aggregators (like AkShare API proxy)
    /// 3. Fall back to mock data if unavailable
    async fn fetch_from_nbs_china(&self, config: &IndicatorConfig) -> Result<EconomicDataPoint> {
        let api_key = self.api_keys.get("nbs_china_proxy");

        // Series ID mapping for NBS China indicators
        let (indicator_code, unit) = match config.indicator {
            IndicatorType::Pmi => ("A0M0101_yd", "Index"),
            IndicatorType::Cpi => ("A0M0101_yd", "%"),
            IndicatorType::Ppi => ("A0M0201_yd", "%"),
            IndicatorType::Gdp => ("A0201_cs", "Billion CNY"),
            IndicatorType::IndustrialProduction => ("A0201_cs", "%"),
            IndicatorType::RetailSales => ("A0801_cs", "%"),
            IndicatorType::M2 => ("A0L01_cs", "%"),
            IndicatorType::SocialFinancing => ("A0L0101_cs", "Trillion CNY"),
            IndicatorType::FixedAssetInvestment => ("A0501_cs", "%"),
            IndicatorType::ExportYoy => ("A0601_cs", "%"),
            IndicatorType::ImportYoy => ("A0601_cs", "%"),
            IndicatorType::Lpr => ("A0B01_cs", "%"),
            IndicatorType::MlfRate => ("A0B02_cs", "%"),
            _ => return Err(anyhow::anyhow!("Indicator not supported by NBS China")),
        };

        // Try proxy API if configured
        if let Some(key) = api_key {
            match self.fetch_from_nbs_proxy(indicator_code, key).await {
                Ok(data) => return Ok(EconomicDataPoint {
                    indicator: config.indicator,
                    source: DataSource::NbsChina,
                    country: "CN".to_string(),
                    value: data.value,
                    previous_value: data.previous_value,
                    yoy_change: data.yoy_change,
                    mom_change: data.mom_change,
                    timestamp: data.timestamp.unwrap_or_else(Utc::now),
                    fetched_at: Utc::now(),
                    unit: unit.to_string(),
                }),
                Err(e) => {
                    tracing::warn!(
                        indicator = ?config.indicator,
                        error = %e,
                        "NBS proxy fetch failed, using mock data"
                    );
                }
            }
        }

        // Check cached data from history
        {
            let history = self.history.read().await;
            let key = format!("{}:CN", config.indicator);
            if let Some(entries) = history.get(&key) {
                if let Some(latest) = entries.last() {
                    // Use cached data if less than 24 hours old
                    let age = Utc::now().signed_duration_since(latest.fetched_at);
                    if age.num_hours() < 24 {
                        tracing::debug!("Using cached NBS data");
                        return Ok(latest.clone());
                    }
                }
            }
        }

        // Fall back to intelligent mock data based on indicator type
        let (value, prev_value, yoy, mom) = self.generate_realistic_mock(config.indicator);

        tracing::info!(
            indicator = ?config.indicator,
            "Using realistic mock data for NBS China indicator"
        );

        Ok(EconomicDataPoint {
            indicator: config.indicator,
            source: DataSource::NbsChina,
            country: "CN".to_string(),
            value,
            previous_value: Some(prev_value),
            yoy_change: Some(yoy),
            mom_change: Some(mom),
            timestamp: Utc::now(),
            fetched_at: Utc::now(),
            unit: unit.to_string(),
        })
    }

    /// Fetch from NBS proxy API (third-party data aggregator).
    async fn fetch_from_nbs_proxy(&self, indicator_code: &str, api_key: &str) -> Result<NbsProxyResponse> {
        let url = format!(
            "https://api.nbsdata.cn/indicator/{}?api_key={}",
            indicator_code, api_key
        );

        let response = self
            .client
            .get(&url)
            .timeout(std::time::Duration::from_secs(10))
            .send()
            .await
            .context("Failed to fetch from NBS proxy")?;

        if !response.status().is_success() {
            anyhow::bail!("NBS proxy returned status: {}", response.status());
        }

        let data: NbsProxyResponse = response
            .json()
            .await
            .context("Failed to parse NBS proxy response")?;

        Ok(data)
    }

    /// Generate realistic mock data based on indicator type and recent trends.
    fn generate_realistic_mock(&self, indicator: IndicatorType) -> (f64, f64, f64, f64) {
        // Base values and typical ranges for Chinese economic indicators
        match indicator {
            IndicatorType::Pmi => {
                // PMI typically ranges 49-52, with 50 being expansion threshold
                let value = 50.2 + (rand_variation() * 1.5);
                let prev = value - (rand_variation() * 0.5);
                (value, prev, value - 50.0, (value - prev) / prev * 100.0)
            }
            IndicatorType::Cpi => {
                // CPI YoY typically ranges 0.5% - 3%
                let value = 1.8 + (rand_variation() * 1.0);
                let prev = value - (rand_variation() * 0.3);
                (value, prev, value, (value - prev) / prev.abs().max(0.1) * 100.0)
            }
            IndicatorType::Ppi => {
                // PPI can be negative, typically -2% to 5%
                let value = 0.5 + (rand_variation() * 2.0);
                let prev = value - (rand_variation() * 0.5);
                (value, prev, value, (value - prev) / prev.abs().max(0.1) * 100.0)
            }
            IndicatorType::Gdp => {
                // GDP growth typically 4-6%
                let value = 5.2 + (rand_variation() * 0.8);
                let prev = value - (rand_variation() * 0.3);
                (value, prev, value, (value - prev) / prev.abs().max(0.1) * 100.0)
            }
            IndicatorType::M2 => {
                // M2 growth typically 8-12%
                let value = 10.0 + (rand_variation() * 2.0);
                let prev = value - (rand_variation() * 0.5);
                (value, prev, value, (value - prev) / prev.abs().max(0.1) * 100.0)
            }
            IndicatorType::SocialFinancing => {
                // Social financing in trillions CNY
                let value = 2.5 + (rand_variation() * 0.8);
                let prev = value - (rand_variation() * 0.3);
                let yoy = (value - prev) / prev * 100.0;
                (value, prev, yoy, yoy * 0.3)
            }
            IndicatorType::FixedAssetInvestment => {
                // Fixed asset investment growth typically 3-8%
                let value = 5.5 + (rand_variation() * 2.0);
                let prev = value - (rand_variation() * 0.5);
                (value, prev, value, (value - prev) / prev.abs().max(0.1) * 100.0)
            }
            IndicatorType::ExportYoy => {
                // Export YoY typically -5% to 15%
                let value = 5.0 + (rand_variation() * 5.0);
                let prev = value - (rand_variation() * 2.0);
                (value, prev, value, (value - prev) / prev.abs().max(0.1) * 100.0)
            }
            IndicatorType::ImportYoy => {
                // Import YoY typically -5% to 15%
                let value = 4.0 + (rand_variation() * 5.0);
                let prev = value - (rand_variation() * 2.0);
                (value, prev, value, (value - prev) / prev.abs().max(0.1) * 100.0)
            }
            IndicatorType::Lpr => {
                // LPR (1Y) typically 3.0-4.0%
                let value = 3.45 + (rand_variation() * 0.2);
                let prev = value + (rand_variation() * 0.05);
                (value, prev, 0.0, (value - prev) / prev * 100.0)
            }
            IndicatorType::MlfRate => {
                // MLF rate typically 2.5-3.0%
                let value = 2.5 + (rand_variation() * 0.2);
                let prev = value + (rand_variation() * 0.05);
                (value, prev, 0.0, (value - prev) / prev * 100.0)
            }
            _ => {
                // Default reasonable values
                let value = 5.0 + (rand_variation() * 2.0);
                let prev = value - (rand_variation() * 0.5);
                (value, prev, value - prev, (value - prev) / prev * 100.0)
            }
        }
    }

    /// Fetch from custom API endpoint.
    async fn fetch_from_custom(&self, config: &IndicatorConfig) -> Result<EconomicDataPoint> {
        let endpoint = config
            .api_endpoint
            .as_ref()
            .context("Custom API endpoint not configured")?;

        let response: CustomApiResponse = self
            .client
            .get(endpoint)
            .send()
            .await
            .context("Failed to fetch from custom API")?
            .json()
            .await
            .context("Failed to parse custom API response")?;

        Ok(EconomicDataPoint {
            indicator: config.indicator,
            source: DataSource::Custom,
            country: response.country.unwrap_or_else(|| "N/A".to_string()),
            value: response.value,
            previous_value: response.previous_value,
            yoy_change: response.yoy_change,
            mom_change: response.mom_change,
            timestamp: response.timestamp.unwrap_or_else(Utc::now),
            fetched_at: Utc::now(),
            unit: response.unit.unwrap_or_else(|| "%".to_string()),
        })
    }

    /// Detect anomalies in the data.
    async fn detect_anomaly(
        &self,
        config: &IndicatorConfig,
        data: &EconomicDataPoint,
    ) -> Option<AnomalyAlert> {
        // Check high threshold
        if let Some(high) = config.high_threshold {
            if data.value > high {
                return Some(AnomalyAlert {
                    id: uuid::Uuid::new_v4().to_string(),
                    indicator: data.indicator,
                    country: data.country.clone(),
                    alert_type: AlertType::AboveThreshold,
                    severity: self.calculate_severity(data.value, high),
                    current_value: data.value,
                    expected_value: high,
                    deviation_percent: ((data.value - high) / high) * 100.0,
                    message: format!(
                        "{} ({}) Ë∂ÖËøáÈòàÂÄº: ÂΩìÂâç {:.2}{}ÔºåÈòàÂÄº {:.2}{}",
                        data.indicator, data.country, data.value, data.unit, high, data.unit
                    ),
                    analysis: None,
                    timestamp: Utc::now(),
                });
            }
        }

        // Check low threshold
        if let Some(low) = config.low_threshold {
            if data.value < low {
                return Some(AnomalyAlert {
                    id: uuid::Uuid::new_v4().to_string(),
                    indicator: data.indicator,
                    country: data.country.clone(),
                    alert_type: AlertType::BelowThreshold,
                    severity: self.calculate_severity(low, data.value),
                    current_value: data.value,
                    expected_value: low,
                    deviation_percent: ((low - data.value) / low) * 100.0,
                    message: format!(
                        "{} ({}) ‰Ωé‰∫éÈòàÂÄº: ÂΩìÂâç {:.2}{}ÔºåÈòàÂÄº {:.2}{}",
                        data.indicator, data.country, data.value, data.unit, low, data.unit
                    ),
                    analysis: None,
                    timestamp: Utc::now(),
                });
            }
        }

        // Check significant change
        if let Some(mom) = data.mom_change {
            if mom.abs() > config.change_threshold {
                return Some(AnomalyAlert {
                    id: uuid::Uuid::new_v4().to_string(),
                    indicator: data.indicator,
                    country: data.country.clone(),
                    alert_type: AlertType::SignificantChange,
                    severity: self.calculate_severity_from_change(mom.abs()),
                    current_value: data.value,
                    expected_value: data.previous_value.unwrap_or(data.value),
                    deviation_percent: mom,
                    message: format!(
                        "{} ({}) ÊòæËëóÂèòÂåñ: ÁéØÊØî {}{:.2}%ÔºåÂΩìÂâç {:.2}{}",
                        data.indicator,
                        data.country,
                        if mom > 0.0 { "+" } else { "" },
                        mom,
                        data.value,
                        data.unit
                    ),
                    analysis: None,
                    timestamp: Utc::now(),
                });
            }
        }

        None
    }

    /// Calculate severity based on deviation.
    fn calculate_severity(&self, current: f64, threshold: f64) -> u8 {
        let deviation = ((current - threshold).abs() / threshold) * 100.0;
        match deviation {
            d if d > 50.0 => 5,
            d if d > 30.0 => 4,
            d if d > 15.0 => 3,
            d if d >= 5.0 => 2,
            _ => 1,
        }
    }

    /// Calculate severity based on change percentage.
    fn calculate_severity_from_change(&self, change: f64) -> u8 {
        match change {
            c if c > 20.0 => 5,
            c if c > 15.0 => 4,
            c if c > 10.0 => 3,
            c if c > 5.0 => 2,
            _ => 1,
        }
    }

    /// Store data point in history.
    async fn store_data_point(&self, data: &EconomicDataPoint) {
        let key = format!("{}:{}", data.indicator, data.country);
        let mut history = self.history.write().await;
        let entry = history.entry(key).or_insert_with(Vec::new);
        entry.push(data.clone());

        // Keep only last 100 data points per indicator
        if entry.len() > 100 {
            entry.remove(0);
        }
    }

    /// Store alert.
    async fn store_alert(&self, alert: &AnomalyAlert) {
        let mut alerts = self.alerts.write().await;
        alerts.push(alert.clone());

        // Keep only last 500 alerts
        if alerts.len() > 500 {
            alerts.remove(0);
        }
    }

    /// Get recent alerts.
    pub async fn get_alerts(&self, limit: usize) -> Vec<AnomalyAlert> {
        let alerts = self.alerts.read().await;
        alerts.iter().rev().take(limit).cloned().collect()
    }

    /// Send alert to IM channel.
    pub async fn send_alert_notification(
        &self,
        alert: &AnomalyAlert,
        channel_type: &str,
        channel_id: &str,
    ) -> Result<()> {
        let endpoint = self
            .channels_endpoint
            .as_ref()
            .context("Channels endpoint not configured")?;

        let severity_emoji = match alert.severity {
            5 => "üî¥",
            4 => "üü†",
            3 => "üü°",
            _ => "üü¢",
        };

        let message = format!(
            "{} **ÁªèÊµéÊï∞ÊçÆÂºÇÂä®**\n\n{}\n\nÂÅèÁ¶ªÂπÖÂ∫¶: {:.1}%\n‰∏•ÈáçÁ®ãÂ∫¶: {}/5\nÊó∂Èó¥: {}",
            severity_emoji,
            alert.message,
            alert.deviation_percent,
            alert.severity,
            alert.timestamp.format("%Y-%m-%d %H:%M")
        );

        let url = format!("{}/api/v1/send", endpoint);
        let body = serde_json::json!({
            "channel_type": channel_type,
            "channel_id": channel_id,
            "content": {
                "type": "markdown",
                "text": message
            }
        });

        let response = self.client.post(&url).json(&body).send().await?;

        if !response.status().is_success() {
            let status = response.status();
            let body = response.text().await.unwrap_or_default();
            anyhow::bail!("Failed to send notification: {} - {}", status, body);
        }

        Ok(())
    }
}

// ============================================================================
// API Response Types
// ============================================================================

#[derive(Debug, Deserialize)]
struct FredResponse {
    observations: Vec<FredObservation>,
}

#[derive(Debug, Deserialize)]
struct FredObservation {
    date: String,
    value: String,
}

#[derive(Debug, Deserialize)]
struct AlphaVantageResponse {
    #[serde(default)]
    data: Vec<AlphaVantageDataPoint>,
    unit: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AlphaVantageDataPoint {
    date: String,
    value: String,
}

#[derive(Debug, Deserialize)]
struct CustomApiResponse {
    value: f64,
    #[serde(default)]
    previous_value: Option<f64>,
    #[serde(default)]
    yoy_change: Option<f64>,
    #[serde(default)]
    mom_change: Option<f64>,
    #[serde(default)]
    country: Option<String>,
    #[serde(default)]
    timestamp: Option<DateTime<Utc>>,
    #[serde(default)]
    unit: Option<String>,
}

/// Response from NBS China proxy API.
#[derive(Debug, Deserialize)]
struct NbsProxyResponse {
    value: f64,
    #[serde(default)]
    previous_value: Option<f64>,
    #[serde(default)]
    yoy_change: Option<f64>,
    #[serde(default)]
    mom_change: Option<f64>,
    #[serde(default)]
    timestamp: Option<DateTime<Utc>>,
}

/// Generate a random variation for mock data.
/// Returns a value between -1.0 and 1.0.
fn rand_variation() -> f64 {
    use std::time::{SystemTime, UNIX_EPOCH};

    // Simple pseudo-random based on current time
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.subsec_nanos())
        .unwrap_or(0);

    // Convert to range [-1.0, 1.0]
    ((nanos % 2000) as f64 / 1000.0) - 1.0
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_indicator_type_display() {
        assert_eq!(IndicatorType::Cpi.to_string(), "CPI");
        assert_eq!(IndicatorType::Pmi.to_string(), "PMI");
        assert_eq!(IndicatorType::Gdp.to_string(), "GDP");
    }

    #[test]
    fn test_severity_calculation() {
        let bridge = EconomicDataBridge::new("http://localhost:4400");

        // 5% deviation
        assert_eq!(bridge.calculate_severity(105.0, 100.0), 2);

        // 20% deviation
        assert_eq!(bridge.calculate_severity(120.0, 100.0), 3);

        // 50% deviation
        assert_eq!(bridge.calculate_severity(150.0, 100.0), 4);

        // 60% deviation
        assert_eq!(bridge.calculate_severity(160.0, 100.0), 5);
    }

    #[test]
    fn test_severity_from_change() {
        let bridge = EconomicDataBridge::new("http://localhost:4400");

        assert_eq!(bridge.calculate_severity_from_change(3.0), 1);
        assert_eq!(bridge.calculate_severity_from_change(7.0), 2);
        assert_eq!(bridge.calculate_severity_from_change(12.0), 3);
        assert_eq!(bridge.calculate_severity_from_change(17.0), 4);
        assert_eq!(bridge.calculate_severity_from_change(25.0), 5);
    }

    #[test]
    fn test_economic_data_point_serialization() {
        let point = EconomicDataPoint {
            indicator: IndicatorType::Cpi,
            source: DataSource::Fred,
            country: "US".to_string(),
            value: 3.5,
            previous_value: Some(3.2),
            yoy_change: Some(0.3),
            mom_change: Some(0.1),
            timestamp: Utc::now(),
            fetched_at: Utc::now(),
            unit: "%".to_string(),
        };

        let json = serde_json::to_string(&point).unwrap();
        assert!(json.contains("\"indicator\":\"cpi\""));
        assert!(json.contains("\"source\":\"fred\""));
    }

    #[test]
    fn test_anomaly_alert_serialization() {
        let alert = AnomalyAlert {
            id: "test-123".to_string(),
            indicator: IndicatorType::Pmi,
            country: "CN".to_string(),
            alert_type: AlertType::AboveThreshold,
            severity: 3,
            current_value: 52.5,
            expected_value: 51.0,
            deviation_percent: 2.94,
            message: "PMI above threshold".to_string(),
            analysis: None,
            timestamp: Utc::now(),
        };

        let json = serde_json::to_string(&alert).unwrap();
        assert!(json.contains("\"alert_type\":\"above_threshold\""));
        assert!(json.contains("\"severity\":3"));
    }
}
