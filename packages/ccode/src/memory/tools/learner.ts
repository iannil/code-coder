/**
 * Dynamic Tool Learner
 *
 * Learns new tools from successful code executions.
 * Analyzes code to extract parameters, generate descriptions, and detect duplicates.
 *
 * Part of Phase 12: Dynamic Tool Library
 */

import { Log } from "@/util/log"
import { ToolTypes } from "./types"
import { ToolRegistry } from "./registry"
import { ToolSearch } from "./search"
import { LLMAbstractor } from "./llm-abstractor"

const log = Log.create({ service: "memory.tools.learner" })

export namespace ToolLearner {
  // ============================================================================
  // Configuration
  // ============================================================================

  export interface LearnerConfig {
    /** Minimum code length to consider for learning */
    minCodeLength: number
    /** Minimum lines to consider for learning */
    minLines: number
    /** Maximum code length to accept */
    maxCodeLength: number
    /** Minimum similarity score to consider duplicate */
    duplicateThreshold: number
    /** Auto-generate description if not provided */
    autoGenerateDescription: boolean
    /** Extract parameters from code */
    extractParameters: boolean
    /** Enable LLM-enhanced abstraction (Phase 17) */
    useLLMAbstraction: boolean
    /** LLM analysis timeout in ms */
    llmAnalysisTimeout: number
  }

  const DEFAULT_CONFIG: LearnerConfig = {
    minCodeLength: 50,
    minLines: 3,
    maxCodeLength: 10000,
    duplicateThreshold: 0.85,
    autoGenerateDescription: true,
    extractParameters: true,
    useLLMAbstraction: true,
    llmAnalysisTimeout: 30000,
  }

  // ============================================================================
  // Main Learning Function
  // ============================================================================

  /**
   * Learn a new tool from a successful execution
   *
   * @returns The learned tool or null if learning was skipped
   */
  export async function learnFromExecution(
    execution: ToolTypes.ExecutionRecord,
    options?: Partial<LearnerConfig>,
  ): Promise<ToolTypes.DynamicTool | null> {
    const config = { ...DEFAULT_CONFIG, ...options }
    const validated = ToolTypes.ExecutionRecord.parse(execution)

    // Quality gates
    const skip = shouldSkipLearning(validated, config)
    if (skip) {
      log.debug("Skipping learning", { reason: skip })
      return null
    }

    // Check for duplicates
    const existing = await findSimilarTool(validated.code, config.duplicateThreshold)
    if (existing) {
      log.debug("Similar tool exists", { existingId: existing.id })
      // Update usage stats on existing tool
      if (validated.durationMs) {
        await ToolRegistry.recordUsage(existing.id, validated.exitCode === 0, validated.durationMs)
      }
      return existing
    }

    // Try LLM-enhanced abstraction first (Phase 17)
    let llmAnalysis: ToolTypes.LLMAnalysisResult | null = null
    if (config.useLLMAbstraction) {
      llmAnalysis = await LLMAbstractor.analyzeCode(validated, {
        timeout: config.llmAnalysisTimeout,
      })
    }

    // Extract tool metadata (use LLM results or fall back to heuristics)
    const name = llmAnalysis?.toolName ?? generateToolName(validated)
    const description = llmAnalysis?.purpose
      ?? (config.autoGenerateDescription ? generateDescription(validated) : validated.task)
    const parameters = llmAnalysis
      ? LLMAbstractor.toToolParameters(llmAnalysis)
      : (config.extractParameters ? extractParameters(validated.code, validated.language) : [])
    const examples = llmAnalysis
      ? LLMAbstractor.toToolExamples(llmAnalysis)
      : [{
          description: `Original task: ${validated.task}`,
          input: {},
          output: validated.output.slice(0, 500),
        }]
    const tags = extractTags(validated)

    // Use generalized code if available, otherwise original
    const code = llmAnalysis?.generalizedCode ?? validated.code

    // Create the tool
    const tool = await ToolRegistry.register({
      name,
      description,
      tags,
      code,
      language: validated.language,
      parameters,
      examples,
      createdBy: "agent",
      sourceTask: validated.task,
    })

    // Update embedding for search
    await ToolSearch.updateEmbedding(tool.id)

    log.info("Tool learned from execution", {
      id: tool.id,
      name: tool.name,
      language: tool.language,
      parameters: parameters.length,
      usedLLM: llmAnalysis !== null,
    })

    return tool
  }

  /**
   * Batch learn from multiple executions
   */
  export async function learnFromExecutions(
    executions: ToolTypes.ExecutionRecord[],
    options?: Partial<LearnerConfig>,
  ): Promise<{ learned: number; skipped: number; duplicates: number }> {
    let learned = 0
    let skipped = 0
    let duplicates = 0

    for (const execution of executions) {
      const result = await learnFromExecution(execution, options)
      if (result === null) {
        skipped++
      } else {
        const isDuplicate = await ToolRegistry.findDuplicate(result.name, result.code)
        if (isDuplicate && isDuplicate.id !== result.id) {
          duplicates++
        } else {
          learned++
        }
      }
    }

    return { learned, skipped, duplicates }
  }

  // ============================================================================
  // Quality Gates
  // ============================================================================

  function shouldSkipLearning(
    execution: ToolTypes.ExecutionRecord,
    config: LearnerConfig,
  ): string | null {
    // Must be successful
    if (execution.exitCode !== 0) {
      return "non-zero exit code"
    }

    // Must have meaningful output
    if (!execution.output || execution.output.trim().length === 0) {
      return "empty output"
    }

    // Code length checks
    if (execution.code.length < config.minCodeLength) {
      return "code too short"
    }
    if (execution.code.length > config.maxCodeLength) {
      return "code too long"
    }

    // Line count check
    const lines = execution.code.split("\n").filter((l) => l.trim().length > 0)
    if (lines.length < config.minLines) {
      return "too few lines"
    }

    // Must have a task description
    if (!execution.task || execution.task.trim().length === 0) {
      return "missing task description"
    }

    // Check for one-off/test code patterns
    if (isOneOffCode(execution.code)) {
      return "appears to be one-off code"
    }

    return null
  }

  function isOneOffCode(code: string): boolean {
    const lowerCode = code.toLowerCase()

    // Test/debug patterns
    const testPatterns = [
      /^console\.log\s*\(/m,
      /^print\s*\(/m,
      /^echo\s+/m,
      /test\s*\(\s*["']/,
      /describe\s*\(/,
      /it\s*\(\s*["']/,
    ]

    // Count how many indicate test/debug code
    let testCount = 0
    for (const pattern of testPatterns) {
      if (pattern.test(code)) testCount++
    }

    // If more than half of the code is test/debug, skip
    const lines = code.split("\n").length
    return testCount > 0 && testCount >= lines / 3

    // Simple one-liners that just print
    // const printOnlyPattern = /^(console\.log|print|echo)\s*\([^)]+\)\s*;?\s*$/
    // if (printOnlyPattern.test(code.trim())) return true

    // return false
  }

  // ============================================================================
  // Duplicate Detection
  // ============================================================================

  async function findSimilarTool(
    code: string,
    threshold: number,
  ): Promise<ToolTypes.DynamicTool | null> {
    // First, check for exact code match
    const tools = await ToolRegistry.list()
    for (const tool of tools) {
      if (normalizeCode(tool.code) === normalizeCode(code)) {
        return tool
      }
    }

    // Then, check for semantic similarity
    const codeDescription = extractCodePurpose(code)
    const similar = await ToolSearch.search(codeDescription, {
      limit: 5,
      minScore: threshold,
    })

    if (similar.length > 0) {
      // Check if the top result is actually similar code
      const topMatch = similar[0]
      const codeSimilarity = calculateCodeSimilarity(code, topMatch.tool.code)
      if (codeSimilarity >= threshold) {
        return topMatch.tool
      }
    }

    return null
  }

  function normalizeCode(code: string): string {
    return code
      .replace(/\s+/g, " ")
      .replace(/['"`]/g, "'")
      .replace(/\/\/.*/g, "") // Remove single-line comments
      .replace(/\/\*[\s\S]*?\*\//g, "") // Remove multi-line comments
      .replace(/#.*/g, "") // Remove Python/bash comments
      .trim()
  }

  function calculateCodeSimilarity(a: string, b: string): number {
    const normA = normalizeCode(a)
    const normB = normalizeCode(b)

    // Jaccard similarity on tokens
    const tokensA = new Set(normA.split(/\s+/))
    const tokensB = new Set(normB.split(/\s+/))

    const intersection = new Set([...tokensA].filter((x) => tokensB.has(x)))
    const union = new Set([...tokensA, ...tokensB])

    return intersection.size / union.size
  }

  // ============================================================================
  // Metadata Extraction
  // ============================================================================

  function generateToolName(execution: ToolTypes.ExecutionRecord): string {
    // Extract key verbs and nouns from the task
    const task = execution.task.toLowerCase()

    // Common action words
    const actions = ["parse", "convert", "transform", "fetch", "download", "upload",
      "calculate", "compute", "generate", "create", "read", "write", "process",
      "extract", "filter", "sort", "search", "find", "validate", "format",
      "encode", "decode", "compress", "decompress", "encrypt", "decrypt",
      "analyze", "aggregate", "merge", "split", "join", "map", "reduce"]

    let action = "process"
    for (const a of actions) {
      if (task.includes(a)) {
        action = a
        break
      }
    }

    // Extract the subject/object
    const words = task.split(/\s+/).filter((w) => w.length > 3)
    const nouns = words.filter((w) => !actions.includes(w.toLowerCase()))
    const subject = nouns.slice(0, 2).join("_") || "data"

    // Language suffix
    const langSuffix = execution.language === "python" ? "py"
      : execution.language === "nodejs" ? "js"
      : "sh"

    return `${action}_${subject}_${langSuffix}`.slice(0, 50)
  }

  function generateDescription(execution: ToolTypes.ExecutionRecord): string {
    const task = execution.task

    // Extract the purpose from the code comments
    const comments = extractComments(execution.code, execution.language)
    if (comments.length > 0) {
      // Use the first substantial comment as description
      const firstComment = comments.find((c) => c.length > 20)
      if (firstComment) {
        return `${task}. ${firstComment}`
      }
    }

    // Otherwise, just use the task with some enhancement
    return `Tool that ${task.toLowerCase()}. Generated from successful execution.`
  }

  function extractComments(code: string, language: string): string[] {
    const comments: string[] = []

    if (language === "python" || language === "bash") {
      // Python/bash single-line comments
      const hashComments = code.match(/#\s*(.+)/g)
      if (hashComments) {
        comments.push(...hashComments.map((c) => c.replace(/^#\s*/, "")))
      }

      // Python docstrings
      const docstrings = code.match(/"""([\s\S]*?)"""|'''([\s\S]*?)'''/g)
      if (docstrings) {
        comments.push(...docstrings.map((d) =>
          d.replace(/^['"`]+|['"`]+$/g, "").trim(),
        ))
      }
    } else {
      // JavaScript/TypeScript comments
      const slashComments = code.match(/\/\/\s*(.+)/g)
      if (slashComments) {
        comments.push(...slashComments.map((c) => c.replace(/^\/\/\s*/, "")))
      }

      // JSDoc and block comments
      const blockComments = code.match(/\/\*\*?([\s\S]*?)\*\//g)
      if (blockComments) {
        comments.push(...blockComments.map((c) =>
          c.replace(/^\/\*\*?|\*\/$/g, "")
            .replace(/^\s*\*\s?/gm, "")
            .trim(),
        ))
      }
    }

    return comments.filter((c) => c.length > 0)
  }

  function extractCodePurpose(code: string): string {
    // Look for function/method names
    const funcMatch = code.match(
      /(?:function|def|const|let|var)\s+(\w+)|(\w+)\s*[=:]\s*(?:async\s+)?(?:function|\([^)]*\)\s*=>)/,
    )
    const funcName = funcMatch?.[1] || funcMatch?.[2] || ""

    // Extract comments
    const comments = extractComments(code, detectLanguage(code))
    const firstComment = comments.find((c) => c.length > 10)

    // Combine
    const parts: string[] = []
    if (funcName) parts.push(`Function: ${funcName}`)
    if (firstComment) parts.push(firstComment)

    return parts.join(". ") || "Code execution"
  }

  function detectLanguage(code: string): ToolTypes.ExecutionRecord["language"] {
    // Simple heuristics
    if (code.includes("def ") || code.includes("import ") || code.match(/:\s*$/m)) {
      return "python"
    }
    if (code.includes("const ") || code.includes("let ") || code.includes("=>")) {
      return "nodejs"
    }
    return "bash"
  }

  // ============================================================================
  // Parameter Extraction
  // ============================================================================

  function extractParameters(
    code: string,
    language: string,
  ): ToolTypes.ToolParameter[] {
    const params: ToolTypes.ToolParameter[] = []
    const seen = new Set<string>()

    // Language-specific patterns
    if (language === "python") {
      params.push(...extractPythonParams(code, seen))
    } else if (language === "nodejs") {
      params.push(...extractJavaScriptParams(code, seen))
    } else {
      params.push(...extractBashParams(code, seen))
    }

    return params
  }

  function extractPythonParams(code: string, seen: Set<string>): ToolTypes.ToolParameter[] {
    const params: ToolTypes.ToolParameter[] = []

    // Function arguments
    const funcMatch = code.match(/def\s+\w+\s*\(([^)]*)\)/)
    if (funcMatch?.[1]) {
      const args = funcMatch[1].split(",").map((a) => a.trim())
      for (const arg of args) {
        const [name, defaultVal] = arg.split("=").map((s) => s.trim())
        if (name && !seen.has(name) && !name.startsWith("*")) {
          seen.add(name)
          params.push({
            name,
            type: inferType(defaultVal),
            description: `Parameter ${name}`,
            required: defaultVal === undefined,
            default: parseDefaultValue(defaultVal),
          })
        }
      }
    }

    // f-string variables
    const fstringVars = code.match(/\{(\w+)\}/g)
    if (fstringVars) {
      for (const match of fstringVars) {
        const name = match.slice(1, -1)
        if (!seen.has(name) && !isBuiltinVar(name)) {
          seen.add(name)
          params.push({
            name,
            type: "string",
            description: `Variable ${name} used in string formatting`,
            required: true,
          })
        }
      }
    }

    return params
  }

  function extractJavaScriptParams(code: string, seen: Set<string>): ToolTypes.ToolParameter[] {
    const params: ToolTypes.ToolParameter[] = []

    // Function arguments
    const funcMatch = code.match(/(?:function\s+\w+|(?:const|let|var)\s+\w+\s*=\s*(?:async\s+)?)\s*\(([^)]*)\)/)
    if (funcMatch?.[1]) {
      const args = funcMatch[1].split(",").map((a) => a.trim())
      for (const arg of args) {
        const [name, defaultVal] = arg.split("=").map((s) => s.trim())
        if (name && !seen.has(name)) {
          seen.add(name)
          params.push({
            name,
            type: inferType(defaultVal),
            description: `Parameter ${name}`,
            required: defaultVal === undefined,
            default: parseDefaultValue(defaultVal),
          })
        }
      }
    }

    // Template literal variables
    const templateVars = code.match(/\$\{(\w+)\}/g)
    if (templateVars) {
      for (const match of templateVars) {
        const name = match.slice(2, -1)
        if (!seen.has(name) && !isBuiltinVar(name)) {
          seen.add(name)
          params.push({
            name,
            type: "string",
            description: `Variable ${name} used in template literal`,
            required: true,
          })
        }
      }
    }

    return params
  }

  function extractBashParams(code: string, seen: Set<string>): ToolTypes.ToolParameter[] {
    const params: ToolTypes.ToolParameter[] = []

    // Positional parameters
    const positionalMatch = code.match(/\$(\d+)/g)
    if (positionalMatch) {
      const positions = new Set(positionalMatch.map((m) => parseInt(m.slice(1))))
      for (const pos of positions) {
        if (pos > 0) {
          const name = `arg${pos}`
          if (!seen.has(name)) {
            seen.add(name)
            params.push({
              name,
              type: "string",
              description: `Positional argument ${pos}`,
              required: true,
            })
          }
        }
      }
    }

    // Named variables
    const namedMatch = code.match(/\$\{?(\w+)\}?/g)
    if (namedMatch) {
      for (const match of namedMatch) {
        const name = match.replace(/^\$\{?|\}?$/g, "")
        if (!seen.has(name) && !isBuiltinBashVar(name) && !/^\d+$/.test(name)) {
          seen.add(name)
          params.push({
            name,
            type: "string",
            description: `Variable ${name}`,
            required: true,
          })
        }
      }
    }

    return params
  }

  function inferType(value: string | undefined): ToolTypes.ToolParameter["type"] {
    if (!value) return "string"

    if (value === "true" || value === "false" || value === "True" || value === "False") {
      return "boolean"
    }
    if (/^-?\d+$/.test(value)) {
      return "number"
    }
    if (/^-?\d+\.\d+$/.test(value)) {
      return "number"
    }
    if (value.startsWith("[") || value.startsWith("(")) {
      return "array"
    }
    if (value.startsWith("{")) {
      return "object"
    }

    return "string"
  }

  function parseDefaultValue(value: string | undefined): unknown {
    if (!value) return undefined

    try {
      return JSON.parse(value)
    } catch {
      // Remove quotes for string values
      if ((value.startsWith("'") && value.endsWith("'")) ||
          (value.startsWith('"') && value.endsWith('"'))) {
        return value.slice(1, -1)
      }
      return value
    }
  }

  function isBuiltinVar(name: string): boolean {
    const builtins = new Set([
      "self", "cls", "this", "super",
      "true", "false", "null", "undefined",
      "None", "True", "False",
      "console", "process", "module", "exports",
      "require", "import", "export",
      "i", "j", "k", "x", "y", "z", "_",
    ])
    return builtins.has(name)
  }

  function isBuiltinBashVar(name: string): boolean {
    const builtins = new Set([
      "HOME", "USER", "PATH", "PWD", "SHELL",
      "IFS", "PS1", "PS2", "RANDOM", "SECONDS",
      "BASH", "BASH_VERSION", "HOSTNAME",
      "0", "?", "!", "$", "#", "*", "@",
    ])
    return builtins.has(name)
  }

  // ============================================================================
  // Tag Extraction
  // ============================================================================

  function extractTags(execution: ToolTypes.ExecutionRecord): string[] {
    const tags = new Set<string>()

    // Add language tag
    tags.add(execution.language)

    // Extract from task description
    const taskLower = execution.task.toLowerCase()

    // Domain tags
    const domainKeywords: Record<string, string[]> = {
      "data-processing": ["parse", "transform", "convert", "process", "extract"],
      "file-io": ["read", "write", "file", "save", "load"],
      "network": ["fetch", "download", "upload", "http", "api", "request"],
      "text": ["string", "text", "format", "regex", "pattern"],
      "math": ["calculate", "compute", "sum", "average", "math"],
      "json": ["json", "parse", "stringify"],
      "csv": ["csv", "comma", "delimit"],
      "xml": ["xml", "html", "dom"],
      "database": ["sql", "query", "database", "db"],
      "crypto": ["encrypt", "decrypt", "hash", "crypto"],
      "compression": ["compress", "decompress", "zip", "gzip"],
      "image": ["image", "png", "jpg", "resize"],
      "date": ["date", "time", "timestamp", "datetime"],
    }

    for (const [tag, keywords] of Object.entries(domainKeywords)) {
      for (const keyword of keywords) {
        if (taskLower.includes(keyword) || execution.code.toLowerCase().includes(keyword)) {
          tags.add(tag)
          break
        }
      }
    }

    return Array.from(tags)
  }
}
