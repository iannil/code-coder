import { describe, test, expect, beforeEach, afterEach } from "bun:test"
import { CrazyState } from "@/crazy/state/states"
import { StateMachine } from "@/crazy/state/state-machine"
import { DecisionEngine, type DecisionContext } from "@/crazy/decision/engine"
import { buildCriteria } from "@/crazy/decision/criteria"
import { Orchestrator, createOrchestrator, type OrchestratorConfig } from "@/crazy/orchestration/orchestrator"
import { Executor, createExecutor, type ExecutionConfig, type TDDPhase } from "@/crazy/execution/executor"
import { CheckpointManager, createCheckpointManager } from "@/crazy/execution/checkpoint"
import { SafetyGuard, parseResourceBudget, type ResourceBudget } from "@/crazy/safety/constraints"
import { SafetyGuardrails, createGuardrails, type GuardrailConfig } from "@/crazy/safety/guardrails"
import { RollbackManager, createRollbackManager, type RollbackTrigger } from "@/crazy/safety/rollback"
import {
  SafetyIntegration,
  createSafetyIntegration,
  isDestructiveOperation,
  getDestructiveRiskLevel,
  type DestructiveOperation,
  type SafetyStatus,
} from "@/crazy/safety/integration"
import { MetricsCollector, createMetricsCollector } from "@/crazy/metrics/metrics"
import { Scorer, createScorer, calculateScores } from "@/crazy/metrics/scorer"
import { CrazyEvent, CrazyEventHelper } from "@/crazy/events"

/**
 * Integration tests for Crazy Mode
 *
 * Tests the interaction between all Crazy Mode components
 */

describe("Crazy Mode Integration", () => {
  let sessionId: string
  let stateMachine: StateMachine
  let decisionEngine: DecisionEngine
  let executor: Executor
  let checkpointManager: CheckpointManager
  let safetyGuard: SafetyGuard
  let guardrails: SafetyGuardrails
  let rollbackManager: RollbackManager
  let safetyIntegration: SafetyIntegration
  let metricsCollector: MetricsCollector
  let scorer: Scorer

  beforeEach(() => {
    sessionId = `test_session_${Date.now()}`
    stateMachine = new StateMachine({ onStateChange: async () => {} })
    decisionEngine = new DecisionEngine({ autonomyLevel: "crazy" })
    executor = createExecutor(sessionId, { unattended: false, maxRetries: 2, checkpointInterval: 5 })
    checkpointManager = createCheckpointManager(sessionId)
    safetyGuard = new SafetyGuard(sessionId)
    guardrails = createGuardrails(sessionId, { loopDetectionEnabled: true, autoBreakLoops: true })
    rollbackManager = createRollbackManager(sessionId, { createCheckpoint: true, maxRetries: 2 })
    safetyIntegration = createSafetyIntegration(sessionId, {
      enableDoomLoopBridge: true,
      enableDestructiveProtection: true,
      autoRollbackOnFailure: false,
    })
    metricsCollector = createMetricsCollector(sessionId)
    scorer = createScorer()
  })

  afterEach(async () => {
    await safetyIntegration.reset()
    await metricsCollector.clear()
    await checkpointManager.clear()
  })

  describe("StateMachine", () => {
    it("should initialize in IDLE state", () => {
      expect(stateMachine.getState()).toBe(CrazyState.IDLE)
    })

    it("should transition to PLANNING state", async () => {
      await stateMachine.transition(CrazyState.PLANNING, { reason: "Starting to plan" })
      expect(stateMachine.getState()).toBe(CrazyState.PLANNING)
    })

    it("should track state history", async () => {
      await stateMachine.transition(CrazyState.PLANNING, { reason: "First" })
      await stateMachine.transition(CrazyState.EXECUTING, { reason: "Second" })
      await stateMachine.transition(CrazyState.TESTING, { reason: "Third" })

      const history = stateMachine.getHistory()
      expect(history.length).toBeGreaterThanOrEqual(3)
    })
  })

  describe("DecisionEngine", () => {
    it("should evaluate decisions using CLOSE framework", () => {
      const criteria = buildCriteria({
        type: "implementation",
        description: "Test decision",
        riskLevel: "low",
        convergence: 7,
        leverage: 8,
        optionality: 6,
        surplus: 7,
        evolution: 8,
      })

      const context: DecisionContext = {
        sessionId,
        currentState: CrazyState.PLANNING,
        resourceUsage: {
          tokensUsed: 1000,
          costUSD: 0.5,
          durationMinutes: 5,
          filesChanged: 3,
          actionsPerformed: 10,
        },
        errorCount: 0,
        recentDecisions: [],
      }

      const result = decisionEngine.evaluate(criteria, context)

      expect(result.action).toBeOneOf(["proceed", "proceed_with_caution", "pause", "block", "skip"])
      expect(result.reasoning).toBeDefined()
      expect(result.approved).toBe(true)
    })

    it("should calculate CLOSE score correctly", () => {
      const criteria = buildCriteria({
        type: "implementation",
        description: "Score test",
        riskLevel: "medium",
        convergence: 5,
        leverage: 7,
        optionality: 8,
        surplus: 6,
        evolution: 7,
      })

      const result = decisionEngine.evaluate(criteria, {
        sessionId,
        currentState: CrazyState.PLANNING,
        resourceUsage: {
          tokensUsed: 50000,
          costUSD: 2.0,
          durationMinutes: 10,
          filesChanged: 10,
          actionsPerformed: 25,
        },
        errorCount: 1,
        recentDecisions: [],
      })

      expect(result.closeScore).toBeGreaterThan(5)
      expect(result.closeScore).toBeLessThan(10)
    })
  })

  describe("SafetyGuard", () => {
    it("should enforce resource limits", async () => {
      const budget: ResourceBudget = {
        maxTokens: 1000,
        maxCostUSD: 1.0,
        maxDurationMinutes: 10,
        maxFilesChanged: 10,
        maxActions: 50,
      }

      const guard = new SafetyGuard(sessionId, budget)

      // Should pass under limit
      const check1 = await guard.check("maxTokens", { tokensUsed: 500 })
      expect(check1.safe).toBe(true)

      // Should fail at limit
      const check2 = await guard.check("maxTokens", { tokensUsed: 1000 })
      expect(check2.safe).toBe(false)

      // Should warn at threshold
      const check3 = await guard.check("maxTokens", { tokensUsed: 850 })
      expect(check3.safe).toBe(true)
      // But warning should have been sent
    })

    it("should calculate surplus ratio correctly", () => {
      const guard = new SafetyGuard(sessionId, {
        maxTokens: 1000,
        maxCostUSD: 10.0,
        maxDurationMinutes: 30,
        maxFilesChanged: 50,
        maxActions: 100,
      })

      const remaining = guard.getRemaining()
      expect(remaining.maxTokens).toBe(1000)
      expect(remaining.maxCostUSD).toBe(10.0)

      // Use 50% of resources
      guard.record("tokensUsed", 500)
      guard.record("costUSD", 5.0)

      const surplus = guard.getSurplusRatio()
      expect(surplus).toBeCloseTo(0.5, 2) // 50% remaining on average
    })
  })

  describe("SafetyGuardrails", () => {
    it("should detect state oscillation loops", () => {
      guardrails.recordStateTransition(CrazyState.PLANNING, CrazyState.EXECUTING)
      guardrails.recordStateTransition(CrazyState.EXECUTING, CrazyState.PLANNING)
      guardrails.recordStateTransition(CrazyState.PLANNING, CrazyState.EXECUTING)

      const stats = guardrails.getStats()
      expect(stats.stateTransitions).toBe(3)
    })

    it("should detect tool call loops", () => {
      for (let i = 0; i < 5; i++) {
        guardrails.recordToolCall("test-tool", { input: "test" }, "error")
      }

      const stats = guardrails.getStats()
      expect(stats.toolCalls).toBe(5)
    })

    it("should detect decision hesitation", () => {
      for (let i = 0; i < 6; i++) {
        guardrails.recordDecision(`decision_${i}`, "test", "pending")
      }

      const stats = guardrails.getStats()
      expect(stats.decisions).toBe(6)
    })

    it("should check limits and return safety status", () => {
      const limits = guardrails.checkLimits()
      expect(limits.safe).toBe(true)
      expect(limits.reason).toBeUndefined()
    })
  })

  describe("RollbackManager", () => {
    it("should create and restore checkpoints", async () => {
      const checkpointId = await rollbackManager.createCheckpoint("test checkpoint")
      expect(checkpointId).toBeDefined()
      expect(checkpointId?.length).toBeGreaterThan(0)

      const canRestore = await rollbackManager.restore(checkpointId, "test restore")
      expect(canRestore).toBe(true)
    })

    it("should handle test failures with rollback", async () => {
      const result = await rollbackManager.handleTestFailure({
        failedTests: ["test1", "test2"],
        totalTests: 10,
        error: "Tests failed",
      })

      // With 20% failure rate, should trigger rollback
      expect(result).toBeDefined()
    })

    it("should track rollback count and retry limit", () => {
      expect(rollbackManager.getRollbackCount()).toBe(0)
      expect(rollbackManager.canRetry()).toBe(true)

      // After reaching max retries
      for (let i = 0; i < 3; i++) {
        await rollbackManager.performRollback("test_id", "test_failure", "Test rollback")
      }

      expect(rollbackManager.getRollbackCount()).toBe(3)
      expect(rollbackManager.canRetry()).toBe(false)
    })
  })

  describe("SafetyIntegration", () => {
    it("should detect destructive operations", () => {
      const bashOp = { tool: "Bash", input: { command: "rm -rf /" } }
      const isDestructive = isDestructiveOperation(bashOp)

      expect(isDestructive).not.toBeNull()
      expect(isDestructive?.category).toBe("file_deletion")
      expect(isDestructive?.riskLevel).toBe("high")
    })

    it("should check destructive operation safety", async () => {
      const highRiskOp: DestructiveOperation = {
        category: "file_deletion",
        description: "Delete important files",
        files: ["/important/file"],
        reversible: false,
        riskLevel: "critical",
      }

      const check = await safetyIntegration.checkSafety({ destructive: highRiskOp })

      expect(check.safe).toBe(false)
      expect(check.destructiveAllowed).toBe(false)
      expect(check.requiresConfirmation).toBe(true)
    })

    it("should record destructive operations", () => {
      const op: DestructiveOperation = {
        category: "git_operations",
        description: "Reset git repository",
        reversible: true,
        riskLevel: "medium",
      }

      safetyIntegration.recordDestructiveOperation(op)

      const status = safetyIntegration.getStatus()
      expect(status.resources).toBeDefined()
    })

    it("should handle failures with rollback", async () => {
      const result = await safetyIntegration.handleFailure("test_failure", {
        reason: "Test failed",
        operation: async () => {
          throw new Error("Test operation failed")
        },
      })

      expect(result.rolledBack).toBe(true)
      expect(result.canRetry).toBe(true)
    })

    it("should get comprehensive safety status", () => {
      const status = safetyIntegration.getStatus()

      expect(status.safe).toBeDefined()
      expect(status.resources).toBeDefined()
      expect(status.loops).toBeDefined()
      expect(status.rollbacks).toBeDefined()
    })
  })

  describe("Executor", () => {
    it("should initialize context", async () => {
      await executor.initialize()
      const context = executor.getContext()
      const metadata = context.get()

      expect(metadata.sessionId).toBe(sessionId)
    })

    it("should track TDD cycle phases", async () => {
      const results = []

      // Mock TDD cycle by directly setting test data
      const context = executor.getContext()
      await context.setMetadata("requirement", "Test feature")
      await context.setMetadata("lastTestFile", "test.spec.ts")

      const metadata = context.get()
      expect(metadata.requirement).toBe("Test feature")
      expect(metadata.lastTestFile).toBe("test.spec.ts")
    })
  })

  describe("MetricsCollector", () => {
    it("should record and aggregate metrics", () => {
      metricsCollector.record("task", "total", 1)
      metricsCollector.record("task", "completed", 1)

      const summary = metricsCollector.getSummary()
      expect(summary.tasks.total).toBe(1)
      expect(summary.tasks.completed).toBe(1)
    })

    it("should track TDD metrics", () => {
      metricsCollector.record("task", "tdd_cycle", 1)
      metricsCollector.record("task", "tdd_red_success", 1)
      metricsCollector.record("task", "tdd_green_success", 1)
      metricsCollector.record("task", "tdd_refactor_success", 1)

      const summary = metricsCollector.getSummary()
      expect(summary.tdd.cycles).toBe(1)
      expect(summary.tdd.redPassed).toBe(1)
      expect(summary.tdd.greenPassed).toBe(1)
      expect(summary.tdd.refactorPassed).toBe(1)
    })

    it("should persist and load metrics", async () => {
      metricsCollector.record("test", "run", 10)
      metricsCollector.record("test", "passed", 8)

      await metricsCollector.persist()

      const loaded = await metricsCollector.load()
      expect(loaded).toBe(true)

      const summary = metricsCollector.getSummary()
      expect(summary.tests.run).toBe(10)
      expect(summary.tests.passed).toBe(8)
    })
  })

  describe("Scorer", () => {
    it("should calculate quality score from metrics", () => {
      const metrics = {
        sessionId,
        startTime: Date.now(),
        duration: 60000, // 1 minute
        tasks: { total: 10, completed: 8, failed: 2, skipped: 0 },
        decisions: { total: 5, approved: 4, paused: 0, blocked: 1, averageScore: 7.5 },
        resources: { tokensUsed: 50000, costUSD: 1.0, filesChanged: 5 },
        tests: { run: 10, passed: 8, failed: 2, passRate: 0.8 },
        tdd: { cycles: 3, redPassed: 3, greenPassed: 3, refactorPassed: 3 },
        safety: { rollbacks: 0, loopsDetected: 0, warnings: 2 },
        states: { transitions: 10, finalState: CrazyState.COMPLETED },
      }

      const qualityScore = scorer.calculateQuality(metrics)

      expect(qualityScore.overall).toBeGreaterThan(0)
      expect(qualityScore.overall).toBeLessThanOrEqual(100)
      expect(qualityScore.testCoverage).toBeGreaterThan(0)
      expect(qualityScore.codeQuality).toBeGreaterThan(0)
    })

    it("should calculate craziness score from metrics", () => {
      const metrics = {
        sessionId,
        startTime: Date.now(),
        duration: 60000,
        tasks: { total: 10, completed: 10, failed: 0, skipped: 0 },
        decisions: { total: 10, approved: 10, paused: 0, blocked: 0, averageScore: 8 },
        resources: { tokensUsed: 50000, costUSD: 1.0, filesChanged: 5 },
        tests: { run: 20, passed: 20, failed: 0, passRate: 1.0 },
        tdd: { cycles: 5, redPassed: 5, greenPassed: 5, refactorPassed: 5 },
        safety: { rollbacks: 0, loopsDetected: 0, warnings: 0 },
        states: { transitions: 5, finalState: CrazyState.COMPLETED },
      }

      const crazinessScore = scorer.calculateCraziness(metrics)

      expect(crazinessScore.overall).toBeGreaterThan(0)
      expect(crazinessScore.level).toBe("lunatic")
      expect(crazinessScore.autonomy).toBe(100)
      expect(crazinessScore.selfCorrection).toBe(50)
    })

    it("should determine craziness level thresholds correctly", () => {
      // Test each level threshold
      const testCases = [
        { score: 95, expected: "lunatic" },
        { score: 80, expected: "insane" },
        { score: 65, expected: "crazy" },
        { score: 50, expected: "wild" },
        { score: 30, expected: "bold" },
        { score: 10, expected: "timid" },
      ]

      for (const testCase of testCases) {
        const level = scorer.calculateCraziness({
          sessionId,
          startTime: Date.now(),
          duration: 60000,
          tasks: { total: 1, completed: 1, failed: 0, skipped: 0 },
          decisions: { total: 1, approved: 1, paused: 0, blocked: 0, averageScore: testCase.score },
          resources: { tokensUsed: 1000, costUSD: 0.1, filesChanged: 1 },
          tests: { run: 10, passed: 10, failed: 0, passRate: 1.0 },
          tdd: { cycles: 1, redPassed: 1, greenPassed: 1, refactorPassed: 1 },
          safety: { rollbacks: 0, loopsDetected: 0, warnings: 0 },
          states: { transitions: 1, finalState: CrazyState.COMPLETED },
        }).level

        expect(level).toBe(testCase.expected)
      }
    })
  })

  describe("Orchestrator Integration", () => {
    it("should create and initialize orchestrator with safety integration", async () => {
      const config: OrchestratorConfig = {
        autonomyLevel: "crazy",
        resourceBudget: {
          maxTokens: 100000,
          maxCostUSD: 5.0,
          maxDurationMinutes: 30,
          maxFilesChanged: 20,
          maxActions: 50,
        },
        unattended: false,
      }

      const orchestrator = createOrchestrator(
        { sessionId, requestId: "test_req", request: "Test request" },
        config,
      )

      await orchestrator.start("Execute the test feature")

      expect(orchestrator.getState()).toBe(CrazyState.PLANNING)
    })

    it("should handle blocked decisions correctly", async () => {
      // This would be tested through full session flow
      // For now, test the decision method exists
      const config: OrchestratorConfig = {
        autonomyLevel: "timid",
        resourceBudget: {
          maxTokens: 1000,
          maxCostUSD: 1.0,
          maxDurationMinutes: 10,
          maxFilesChanged: 5,
          maxActions: 10,
        },
        unattended: false,
      }

      const orchestrator = createOrchestrator(
        { sessionId, requestId: "test_req", request: "Test" },
        config,
      )

      await orchestrator.start("Test")

      // Low autonomy should pause more often
      expect(orchestrator.getState()).toBeDefined()
    })
  })

  describe("CrazyEvent System", () => {
    it("should define all required events", () => {
      const events = [
        "SessionStarted",
        "SessionCompleted",
        "SessionFailed",
        "SessionPaused",
        "TDDCycleStarted",
        "TDDCycleCompleted",
        "StateTransitioned",
        "DecisionMade",
        "DecisionBlocked",
        "ResourceWarning",
        "ResourceExceeded",
        "LoopDetected",
        "CheckpointCreated",
        "RollbackPerformed",
        "AgentInvoked",
      ]

      for (const event of events) {
        expect(CrazyEvent[event]).toBeDefined()
        expect(typeof CrazyEvent[event]).toBe("function")
        expect(typeof CrazyEvent[event]?.define).toBe("function")
      }
    })

    it("should have correct event schemas", () => {
      // Verify ResourceWarning has destructive_operation type
      const resourceWarningSchema = CrazyEvent.ResourceWarning.schema
      expect(resourceWarningSchema).toBeDefined()

      const allowedResources = ["tokens", "cost", "time", "files", "actions", "destructive_operation"]
      const enumValues = resourceWarningSchema?.shape?.resource?.enumValues ?? []
      expect(enumValues).toContain("destructive_operation")
    })
  })

  describe("End-to-End Scenarios", () => {
    it("should handle complete TDD cycle flow", async () => {
      const results: TDDCycleResult[] = []

      const context = executor.getContext()
      await context.setMetadata("requirement", "Implement user authentication")

      // RED phase
      const redResult: TDDCycleResult = {
        phase: "red",
        success: true,
        duration: 1000,
        changes: ["auth.test.ts"],
      }
      results.push(redResult)

      // GREEN phase
      const greenResult: TDDCycleResult = {
        phase: "green",
        success: true,
        duration: 2000,
        changes: ["auth.service.ts"],
      }
      results.push(greenResult)

      // REFACTOR phase
      const refactorResult: TDDCycleResult = {
        phase: "refactor",
        success: true,
        duration: 1500,
        changes: ["Refactored auth service"],
      }
      results.push(refactorResult)

      expect(results.length).toBe(3)
      expect(results.every((r) => r.success)).toBe(true)
    })

    it("should handle safety rollback scenario", async () => {
      // Create a checkpoint
      const checkpointId = await checkpointManager.createCheckpoint("Before risky operation")

      // Simulate failure
      const rollbackResult = await safetyIntegration.handleFailure("test_failure", {
        reason: "Operation failed",
      })

      expect(rollbackResult.rolledBack).toBe(true)
      expect(rollbackResult.canRetry).toBe(true)
    })

    it("should detect and break DOOM loops", async () => {
      const loopCallback = jest.fn()

      safetyIntegration.onDoomLoop(loopCallback)

      // Simulate tool calls that would trigger DOOM_LOOP
      for (let i = 0; i < 3; i++) {
        safetyIntegration.recordToolCall("failing-tool", { input: "test" }, "error")
      }

      // Callback should have been called
      expect(loopCallback).toHaveBeenCalled()
    })
  })
})
