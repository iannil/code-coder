# AGENTS.md

CodeCoder Agent 系统详细说明文档。

## Agent 能力矩阵

CodeCoder 内置 23 个专业 Agent，按三层智慧架构组织：

```
┌─────────────────────────────────────────────────────────────┐
│                      思维智囊层                              │
│   observer · decision                                       │
├─────────────────────────────────────────────────────────────┤
│                      领域智囊层                              │
│   macro · trader · picker                                   │
│   miniproduct · ai-engineer · synton-assistant              │
├─────────────────────────────────────────────────────────────┤
│                      工程智囊层                              │
│   code-reviewer · security-reviewer · tdd-guide · architect │
│   code-reverse · jar-code-reverse · explore · general       │
├─────────────────────────────────────────────────────────────┤
│                      内容智囊层                              │
│   writer · proofreader                                      │
└─────────────────────────────────────────────────────────────┘
```

---

## 工程智囊层

帮助高效完成技术工作，保证代码质量与系统安全。

### build

**类型**: Primary Mode
**权限**: 完整读写权限
**用途**: 主要开发模式，拥有完整的文件操作、代码编辑和命令执行能力。

### plan

**类型**: Primary Mode
**权限**: 只读权限
**用途**: 代码探索和规划模式，用于分析代码库、理解架构、制定实施计划。

### code-reviewer

**类型**: Subagent
**用途**: 代码质量审查
**能力**:
- 识别代码异味和反模式
- 检查命名规范和代码风格
- 评估可维护性和可读性
- 提供具体可操作的改进建议

**使用场景**: 代码提交前审查、PR 评审、代码重构前评估

### security-reviewer

**类型**: Subagent
**用途**: 安全漏洞分析
**能力**:
- 检测 OWASP Top 10 漏洞
- 识别注入攻击风险（SQL、XSS、命令注入）
- 检查认证授权问题
- 发现敏感数据泄露风险

**使用场景**: 安全审计、敏感代码审查、上线前安全检查

### tdd-guide

**类型**: Subagent
**用途**: 测试驱动开发指导
**能力**:
- 引导红-绿-重构循环
- 设计测试用例和边界条件
- 确保测试覆盖率达标（80%+）
- 指导测试代码质量

**使用场景**: 新功能开发、Bug 修复、代码重构

### architect

**类型**: Subagent
**用途**: 系统架构设计
**能力**:
- 设计系统架构和模块划分
- 定义接口和数据模型
- 选择技术方案和设计模式
- 评估架构权衡和技术债务

**使用场景**: 新项目启动、系统重构、技术方案评审

### code-reverse

**类型**: Primary Mode
**权限**: 计划模式权限
**用途**: 网站逆向工程
**能力**:
- 分析网站技术栈和框架
- 提取设计系统和组件结构
- 识别 API 和数据流
- 生成像素级还原开发计划

**使用场景**: 学习优秀网站实现、竞品分析、UI 复刻

### jar-code-reverse

**类型**: Primary Mode
**权限**: 计划模式权限
**用途**: JAR 文件逆向工程
**能力**:
- 分析 Java 类结构和依赖
- 识别框架和库
- 提取业务逻辑模式
- 生成源码重构计划

**使用场景**: 遗留系统分析、第三方库研究、代码考古

### explore

**类型**: Subagent
**用途**: 快速代码库探索
**能力**:
- 按模式搜索文件
- 按关键词搜索代码
- 理解代码结构和依赖关系
- 回答代码库相关问题

**使用场景**: 快速熟悉新代码库、定位特定功能实现、理解项目结构

### general

**类型**: Subagent
**用途**: 通用多步骤任务执行
**能力**:
- 执行复杂的多步骤任务
- 并行处理多个工作单元
- 研究复杂问题并提供答案

**使用场景**: 需要多步骤协作的复杂任务

---

## 领域智囊层

深耕特定领域，提供专业级的分析与指导。

### macro

**类型**: Subagent (ZRS系列)
**用途**: 宏观经济分析
**温度**: 0.5
**能力**:
- GDP、工业增加值、PMI 等核心指标分析
- 通胀、货币、信贷等金融数据解读
- 进出口、外汇等国际收支分析
- 经济周期位置识别和政策周期解读

**使用场景**: 经济数据解读、政策影响分析、市场趋势预判

### trader

**类型**: Subagent (ZRS系列)
**用途**: 超短线交易指南
**温度**: 0.5
**能力**:
- 情绪周期分析（混沌期、发酵期、高潮期、退潮期）
- 龙头战法和模式识别
- 仓位管理和风险控制
- 技术形态分析

**使用场景**: 交易教育、技术分析学习、市场情绪判断

**重要声明**: 仅供教育参考，不构成投资建议。

### picker

**类型**: Subagent (ZRS系列)
**用途**: 选品策略专家
**温度**: 0.6
**能力**:
- 七宗罪选品法（贪婪、懒惰、虚荣、淫欲、嫉妒、暴怒、傲慢）
- 痛点-痒点-爽点需求模型
- 蓝海市场机会识别
- 数据验证和爆款潜力评估

**使用场景**: 产品选品、市场机会发现、需求挖掘

### miniproduct

**类型**: Subagent (ZRS系列)
**用途**: 极小产品教练
**温度**: 0.6
**能力**:
- 需求挖掘和验证（48小时验证法）
- MVP 设计（最简赚钱流程）
- AI 辅助开发策略
- 变现模式和退出策略

**使用场景**: 独立开发者从0到1、产品想法验证、侧项目规划

### ai-engineer

**类型**: Subagent (ZRS系列)
**用途**: AI 工程师导师
**温度**: 0.5
**能力**:
- Python 工程化基础
- LLM 应用开发（Prompt Engineering、RAG、Agent）
- 模型微调和推理优化
- MLOps 最佳实践

**使用场景**: AI 工程学习、LLM 应用开发、系统优化

### synton-assistant

**类型**: Subagent
**用途**: SYNTON-DB 认知数据库助手
**温度**: 0.5
**能力**:
- 张量图存储理解和使用
- PaQL 查询语言指导
- Graph-RAG 检索策略
- 记忆系统设计

**使用场景**: 认知数据库集成、知识图谱构建、LLM 记忆系统设计

---

## 思维智囊层

基于"祝融说"哲学体系，提升认知层次，帮助做出更明智的决策。

### observer

**类型**: Subagent (ZRS系列)
**用途**: 观察者理论顾问
**温度**: 0.7
**核心框架**:

**本体论 - 实在的生成**
- 可能性基底：宇宙是包含一切潜能的无限场域
- 观察即收敛：观察导致可能性"坍缩"为确定性
- 观察共识：宏观世界的稳定性源于多层级观察者的"共同投票"

**认识论 - 认知的工具**
- 过程性完备：认知的完备性在于迭代能力
- 语言建构：每次命名都是对无限可能性的"收敛"
- 理论降维：所有理论都是对实在的"降维投影"

**实践论 - 行动的智慧**
- 可用余量：尚未被固化的潜能空间
- 选择权优势：智慧选择在于为未来"预留可能性"
- 容错机制：多样性、冗余性、去中心化是韧性的三大支柱

**使用场景**: 困境分析、认知升级、身份重塑、揭示隐藏的可能性空间

### decision

**类型**: Subagent (ZRS系列)
**用途**: 决策智慧师
**温度**: 0.6
**核心框架**:

**CLOSE 五维评估法**
- **C - Convergence（收敛程度）**: 选择收敛多少可能性？
- **L - Leverage（杠杆效应）**: 是否存在非对称收益？
- **O - Optionality（选择权保留）**: 选择后还能反悔吗？
- **S - Surplus（余量消耗）**: 消耗多少时间/金钱/精力余量？
- **E - Evolution（演化空间）**: 能带来成长和学习吗？

**实战工具**
- 反脆弱检验
- 10-10-10法则
- 预谋遗忘（Pre-mortem）
- 可逆性改造

**使用场景**: 职业选择、投资决策、关系承诺、创业启动

---

## 内容智囊层

高质量内容创作与校对。

### writer

**类型**: Subagent
**用途**: 长文写作专家
**温度**: 0.7
**能力**:
- 大纲生成和章节规划
- 逐章写作和风格一致性
- 20k+ 字长文结构化写作
- 多种文体和风格适配

**使用场景**: 技术文档、报告撰写、内容创作

### proofreader

**类型**: Subagent
**用途**: 内容校对专家
**温度**: 0.3
**能力**:
- 语法、拼写、标点检查
- 风格一致性和术语规范
- 流畅性和可读性评估
- 结构和逻辑审核（PROOF框架）

**使用场景**: 文档发布前校对、内容质量把关

---

## Agent 协作模式

### 单 Agent 模式

直接使用特定 Agent 完成任务：

```
> "@decision 用CLOSE框架分析这个职业选择"
```

### 链式协作

多个 Agent 依次处理：

```
1. architect → 设计架构
2. tdd-guide → 编写测试
3. code-reviewer → 审查代码
4. security-reviewer → 安全审计
```

### 并行协作

多个 Agent 同时工作：

```
parallel:
  - security-reviewer → 安全分析
  - code-reviewer → 代码质量
  - architect → 架构评估
```

---

## 典型使用场景

### 场景1：新功能开发

```
1. @architect 设计功能架构
2. @tdd-guide 编写测试用例
3. 实现功能代码
4. @code-reviewer 审查代码质量
5. @security-reviewer 安全检查
```

### 场景2：代码库探索

```
1. @explore 理解代码结构
2. plan 模式深入分析
3. 定位关键实现
```

### 场景3：决策支持

```
1. @observer 分析问题框架
2. @decision CLOSE五维评估
3. 制定行动计划
```

### 场景4：产品验证

```
1. @picker 评估市场机会
2. @miniproduct 设计验证方案
3. @ai-engineer AI功能规划
```

### 场景5：经济分析

```
1. @macro 解读核心数据
2. @trader 识别市场情绪
3. 制定应对策略
```

---

## 自定义 Agent

可以在 `~/.ccode/agents.json` 中定义自定义 Agent：

```json
{
  "agents": [
    {
      "name": "my-advisor",
      "description": "My custom advisor",
      "mode": "subagent",
      "permission": "read",
      "systemPrompt": "You are an expert in...",
      "temperature": 0.6
    }
  ]
}
```

### 配置字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `name` | string | Agent 名称 |
| `description` | string | Agent 描述 |
| `mode` | "primary" \| "subagent" | 模式类型 |
| `permission` | object | 权限配置 |
| `systemPrompt` | string | 系统提示词 |
| `temperature` | number | 温度参数 (0-1) |
| `model` | string | 指定模型 |

---

## 代码风格指南

在使用 Agent 时请遵循以下代码风格：

- 避免使用 `let` 语句 - 优先使用 `const` 和三元运算符
- 避免使用 `else` 语句 - 使用提前返回
- 避免不必要的解构 - 使用 `obj.a` 而不是 `const { a } = obj`
- 尽可能避免 `try`/`catch` - 优先使用 `.catch()`
- 避免使用 `any` 类型
- 优先使用单字变量名
- 除非可组合/可重用，否则将逻辑保持在一个函数中
- 尽可能使用 Bun API
